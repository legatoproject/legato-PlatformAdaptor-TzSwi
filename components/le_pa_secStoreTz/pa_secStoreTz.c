/**
 * @file pa_secStoreTz.c
 *
 * TrustZone implementation of @ref c_pa_secStore API.
 *
 * This Platform Adapter implementation of the Secure Storage stores data in the configTree.
 * The data is encrypted/decrypted using the keys provided by Sierra Wireless TrustZone solution.
 *
 * A unique key is generated for each application with the name of the app and stored in a keys
 * file. The key file is protected through SMACK under the applications' appWriteable directory.
 * Paths that are not apart of an application e.g. system paths or globals, secure storage will use
 * a general user key. Keys will be used to encrypt or decrypt data.
 *
 * There are three secure storage path use cases managed:
 * | Path type                  | Details                                                        |
 * |----------------------------|----------------------------------------------------------------|
 * | AVMS Keys                  | The AVMS keys are provisioned in modem SFS. Therefore we will  |
 * |                            | need to rely on QMI to access SFS in this specific case.       |
 * |                            |                                                                |
 * | Application keys           | A new key for each unique application.                         |
 * |                            |                                                                |
 * | User key                   | Key used to manage system paths that are not application paths.|
 * |----------------------------|----------------------------------------------------------------|
 *
 * The secure storage data is stored in the following format (example):
* /
  sys/
    1/
      apps/
        test/
            secret<string> == pv9DtEVd1TVI7Dit41PEJZk/jiP+aDGlaO72YpgQrzYOwhXIVdd+vdHHla5yxhk=
      hash<string> == AUbdSg9/Z744m/UJzaGGHgrKSzcmUVnNZzc/CgjIc1G4
  isPorted<bool> == true
  global/
    file1<string> == aGGHgrK
 *
 *
 * Copyright (C) Sierra Wireless Inc.
 */

#include "legato.h"
#include "limit.h"
#include "interfaces.h"
#include "pa_secStore.h"
#include "trustZone.h"
#include "iksCrypto.h"

#include "sfsSecStore.h"


//--------------------------------------------------------------------------------------------------
/**
 * Config path to the secure storage content.
 */
//--------------------------------------------------------------------------------------------------
#define CFG_SECSTORE            "secStore:/"
#define CFG_SECSTORE_USER_PATH  ".user" // special keyword for other non application paths


//--------------------------------------------------------------------------------------------------
/**
 * Location of the key file. This file is used to store the keys generated by TrustZone.
 */
//--------------------------------------------------------------------------------------------------
#ifdef LE_CONFIG_LINUX
#define KEY_FILE      "keys"
#else
#define KEY_FILE      "iotkeys"
#endif /// LE_CONFIG_LINUX


//--------------------------------------------------------------------------------------------------
/**
 * Location of meta data file.  This meta data file is used to store a mapping between sfs file
 * names and user specified paths.
 */
//--------------------------------------------------------------------------------------------------
#define META_FILE                   "/legato/meta"


//--------------------------------------------------------------------------------------------------
/**
 * Temporary version of meta data file from SFS.
 */
//--------------------------------------------------------------------------------------------------
#define TMP_META_FILE               "/tmp/meta"


//--------------------------------------------------------------------------------------------------
/**
 * Index of the application name
 */
//--------------------------------------------------------------------------------------------------
#ifdef LE_CONFIG_LINUX
#define PATH_APP_NAME_INDEX         3
#elif LE_CONFIG_TARGET_GILL
#define PATH_APP_NAME_INDEX         1
#else
#error "Target not supported"
#endif


//--------------------------------------------------------------------------------------------------
/**
 * Max size of encrypted data.
 */
//--------------------------------------------------------------------------------------------------
#define MAX_ENCRYPTED_DATA_BYTES    12288

//--------------------------------------------------------------------------------------------------
/**
 * Max number of encrypted data buffers
 */
//--------------------------------------------------------------------------------------------------
#define MAX_ENCRYPTED_BUFFERS       2

//--------------------------------------------------------------------------------------------------
/**
 * Memory pool for encrypted data buffers
 */
//--------------------------------------------------------------------------------------------------
LE_MEM_DEFINE_STATIC_POOL(EncryptedBuffer, MAX_ENCRYPTED_BUFFERS, MAX_ENCRYPTED_DATA_BYTES);

//--------------------------------------------------------------------------------------------------
/**
 * Ecrypted Data Pool Handle
 */
//--------------------------------------------------------------------------------------------------
static le_mem_PoolRef_t EncryptedBufferPool = NULL;

//--------------------------------------------------------------------------------------------------
/**
 * Total available space of the secure storage, in bytes.
 * It's not enforced, but needed to return some number from GetTotalSpace() API.
 */
//--------------------------------------------------------------------------------------------------
#define SECSTORE_TOTAL_SPACE        (1024 * 1024)


//--------------------------------------------------------------------------------------------------
/**
 * Flag to indicate if the sfs is ready for user access.
 */
//--------------------------------------------------------------------------------------------------
static bool SfsReady = false;


//--------------------------------------------------------------------------------------------------
/**
 * Array of HashMaps holding encrytpion keys.
 */
//--------------------------------------------------------------------------------------------------
static le_hashmap_Ref_t KeyMap[LE_SECSTORE_VERSION_IKS + 1] = {NULL};


//--------------------------------------------------------------------------------------------------
/**
 * Estimated maximum number of keys.
 */
//--------------------------------------------------------------------------------------------------
#define ESTIMATED_MAX_KEYS             8


//--------------------------------------------------------------------------------------------------
/**
 * Memory pool of key objects
 */
//--------------------------------------------------------------------------------------------------
static le_mem_PoolRef_t KeyPool = NULL;

//--------------------------------------------------------------------------------------------------
/**
 * TrustZone4 enabled path
 */
//--------------------------------------------------------------------------------------------------
#define SIERRA_TZDEV4_ENABLED_PATH       "/sys/module/sierra_tzdev/parameters/tz4_enabled"

//--------------------------------------------------------------------------------------------------
/**
 * Current version of the SecStore data storage: depends on whether IKS is enabled, and whether
 * the current platform is Linux or RTOS.
 */
//--------------------------------------------------------------------------------------------------
static le_secStore_Version_t CURRENT_SECSTORE_VERSION = LE_SECSTORE_VERSION_TZ;

//--------------------------------------------------------------------------------------------------
/**
 * Key object
 */
//--------------------------------------------------------------------------------------------------
typedef struct {
    char name[LIMIT_MAX_APP_NAME_BYTES];
    uint8_t blob[KM_MAX_KEY_SIZE];
    uint32_t blobSize;
}
Key_t;


//--------------------------------------------------------------------------------------------------
/**
 * Path types.
 */
//--------------------------------------------------------------------------------------------------
typedef enum {
    PATH_TYPE_PATH = 0x0,        ///< A path.
    PATH_TYPE_APP_PATH = 0x1,    ///< A path that belongs to an app.
    PATH_TYPE_AVMS_PATH = 0x2,   ///< A path that belongs specifically for avms.
}
PathType_t;


//--------------------------------------------------------------------------------------------------
/**
 * Path Class
 */
//--------------------------------------------------------------------------------------------------
typedef struct {
    char pattern[LIMIT_MAX_APP_NAME_BYTES];
    PathType_t type;
}
PathClass_t;


//--------------------------------------------------------------------------------------------------
/**
 * Paths pattern match. Used to determine how we manage different paths.
 */
//--------------------------------------------------------------------------------------------------
static const PathClass_t PathClasses[] = {
#ifdef LE_CONFIG_LINUX
    { "/sys/*/apps/avcService/avms/LWM2M_BOOTSTRAP*", PATH_TYPE_AVMS_PATH },
    { "/sys/*/apps/avcService/avms/LWM2M_FW_KEY", PATH_TYPE_AVMS_PATH },
    { "/sys/*/apps/avcService/avms/LWM2M_SW_KEY", PATH_TYPE_AVMS_PATH },
    { "/sys/*/apps/avcService/avms/certificate", PATH_TYPE_AVMS_PATH },
    { "/sys/*/apps/avcService/avms/bs_server_public_key", PATH_TYPE_AVMS_PATH },
    { "/sys/*/apps/*", PATH_TYPE_APP_PATH }
#elif LE_CONFIG_TARGET_GILL
    { "avcService/avms/LWM2M_BOOTSTRAP*", PATH_TYPE_AVMS_PATH },
    { "avcService/avms/LWM2M_FW_KEY", PATH_TYPE_AVMS_PATH },
    { "avcService/avms/LWM2M_SW_KEY", PATH_TYPE_AVMS_PATH },
    { "avcService/avms/certificate", PATH_TYPE_AVMS_PATH },
    { "avcService/avms/bs_server_public_key", PATH_TYPE_AVMS_PATH },
    { "*", PATH_TYPE_APP_PATH }
#else
#error "Target not supported"
#endif
};

//--------------------------------------------------------------------------------------------------
/**
 * Context for PortDataEntry callback
 */
//--------------------------------------------------------------------------------------------------
typedef struct
{
    le_secStore_Version_t   version;
    le_cfg_IteratorRef_t    writeIter;
}
EntryContext_t;

//--------------------------------------------------------------------------------------------------
/**
 * Prototype for iteratively getting entries.
 */
//--------------------------------------------------------------------------------------------------
typedef void (*pa_secStore_GetEntry_t)
(
    const char* entryPathPtr,       ///< [IN] Entry path.
    const char* entryPtr,           ///< [IN] Entry name.
    bool isDir,                     ///< [IN] true if the entry is a directory, otherwise entry is a
                                    ///       file.
    void* contextPtr                ///< [IN] Pointer to the context supplied to
                                    ///       pa_secStore_GetEntries()
);


//--------------------------------------------------------------------------------------------------
/**
 * Perform shell-gobbing style pattern matching
 */
//--------------------------------------------------------------------------------------------------
static bool MatchPattern
(
    const char *pattern,           ///< [IN] Pattern to match
    const char *str                ///< [IN] String to match against the pattern

)
{
    while (*pattern && *str)
    {
        // For '*', match a run of characters
        if (*pattern == '*')
        {
            while (*str)
            {
                if (pattern[1] != str[0])
                {
                    // If next character in pattern doesn't match next character in string,
                    // move ahead in the string
                    ++str;
                }
                else if (MatchPattern(&pattern[1], &str[0]))
                {
                    // If remainder of pattern matches remainder of string, return true
                    return true;
                }
                else
                {
                    // Otherwise try again on the next character of the string
                    ++str;
                }
            }
        }
        else if (*pattern == *str)
        {
            ++str;
        }
        else
        {
            break;
        }

        ++pattern;
    }

    return *pattern == *str;
}


//--------------------------------------------------------------------------------------------------
/**
 * Determine the path type.
 */
//--------------------------------------------------------------------------------------------------
static PathType_t GetPathType
(
    const char* pathPtr
)
{
    size_t classCnt = sizeof(PathClasses) / sizeof(PathClasses[0]);

    int i = 0;
    for (i = 0; i < classCnt; i++)
    {
        if (MatchPattern(PathClasses[i].pattern, pathPtr))
        {
            return PathClasses[i].type;
        }
    }

    return PATH_TYPE_PATH;
}


//--------------------------------------------------------------------------------------------------
/**
 * Get the application name from the path.
 *
 * @return
 *      LE_OK if the application name is found.
 *      LE_NOT_FOUND if the application name is not found.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t GetApplicationName
(
    const char* pathPtr,    ///< [IN] Path.
    char* appNamePtr,       ///< [OUT] Name of the application if the path is an application path.
    size_t appNameSize      ///< [IN/OUT] Size of the application buffer.
)
{
    le_result_t result = LE_NOT_FOUND;
    le_pathIter_Ref_t iteratorRef = le_pathIter_CreateForUnix(pathPtr);
    int pathIterCount = 0;

    if (le_pathIter_IsEmpty(iteratorRef))
    {
        result = LE_FAULT;
        goto out;
    }

    le_pathIter_GoToStart(iteratorRef);

    // Assume the path contains app name at a certain position, depending on platform
    // and defined by PATH_APP_NAME_INDEX
    do
    {
        char buffer[LIMIT_MAX_APP_NAME_BYTES] = { 0 };
        if (le_pathIter_GetCurrentNode(iteratorRef, buffer, LIMIT_MAX_APP_NAME_BYTES) != LE_OK)
        {
            result = LE_FAULT;
            goto out;
        }

        // This should be our app name
        if (pathIterCount == PATH_APP_NAME_INDEX)
        {
            result = le_utf8_Copy(appNamePtr, buffer, appNameSize, NULL);

            if (result != LE_OK)
            {
                result = LE_FAULT;
                goto out;
            }

            result = LE_OK;
            goto out;
        }

        pathIterCount++;
    }
    while (le_pathIter_GoToNext(iteratorRef) != LE_NOT_FOUND);

    result = LE_NOT_FOUND;

out:
    le_pathIter_Delete(iteratorRef);
    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Generate a new key for a given key name. Generally the key name is the name of the application.
 * The key name, key blob and key size will be stored in a key file within the working directory
 * of the service that uses the trustZone PA. The key file is protected by smack and can only be
 * accessed by the secure storage service.
 *
 * @return
 *      LE_OK if a new key is successfully generated and stored.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t GenerateKey
(
    le_secStore_Version_t version,  ///< [IN] Secure Storage version.
    const char* keyName             ///< [IN] Name of the key.
)
{
    LE_DEBUG("Generating new key: name %s version %u", keyName, version);

    // Open the sfs file.
    int fd = le_atomFile_Create(KEY_FILE,
                                LE_FLOCK_READ_AND_APPEND,
                                LE_FLOCK_OPEN_IF_EXIST,
                                S_IRWXU);

    if (fd < 0)
    {
        le_atomFile_Cancel(fd);
        LE_ERROR("Failed to open %s", KEY_FILE);
        return LE_FAULT;
    }

    Key_t* key = le_mem_ForceAlloc(KeyPool);
    memset(key, 0, sizeof(*key));
    le_utf8_Copy(key->name, keyName, sizeof(key->name), NULL);

    if (keyName && (version == CURRENT_SECSTORE_VERSION))
    {
        // Write the path to the file.
        if (le_fd_Write(fd, key->name, sizeof(key->name)) != sizeof(key->name))
        {
            goto handleWriteError;
        }

        // Generate key for this app
        key->blobSize = sizeof(key->blob);
        le_result_t result = LE_FAULT;
#if LE_CONFIG_SECSTORE_IKS_BACKEND
        if (version == LE_SECSTORE_VERSION_IKS)
        {
            result = iksCrypto_GenerateKey(key->blob, &key->blobSize);
        }
#endif
#if LE_CONFIG_LINUX
        if (version == LE_SECSTORE_VERSION_TZ)
        {
            result = tz_GenerateKey(key->blob, &key->blobSize);
        }
#endif
        if (result != LE_OK)
        {
            LE_ERROR("Error generating key of version %u", version);
            goto handleWriteError;
        }

        if (le_fd_Write(fd, &key->blobSize, sizeof(uint32_t)) != sizeof(uint32_t))
        {
           goto handleWriteError;
        }

        if (le_fd_Write(fd, key->blob, sizeof(key->blob)) != sizeof(key->blob))
        {
           goto handleWriteError;
        }

        LE_DEBUG("Writing key [name: %s] [size: %d]", key->name, key->blobSize);
    }

    le_atomFile_Close(fd);
    le_hashmap_Put(KeyMap[version], key->name, key);
    return LE_OK;

handleWriteError:
    LE_ERROR("Failed to write key data.");
    le_mem_Release(key);
    le_atomFile_Cancel(fd);
    return LE_FAULT;
}


//--------------------------------------------------------------------------------------------------
/**
 * Get the key blob of a specific key name. Generally the key name will be the name of an app.
 * If a key does not exist for a key name, this function will generate a new one.
 *
 * @return
 *      LE_OK if a key is returned successfully.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t GetKey
(
    le_secStore_Version_t version,      ///< [IN] Secure Storage version.
    const char* keyName,                ///< [IN] Name of the key.
    uint8_t* keyPtr,                    ///< [IN/OUT] Key blob for the specified key name.
    uint32_t* keySize                   ///< [IN/OUT] Size of the key blob.
)
{
    const Key_t* key = le_hashmap_Get(KeyMap[version], keyName);

    if (key == NULL)
    {
        LE_DEBUG("Generating new key for: %s version %u", keyName, version);
        le_result_t result = GenerateKey(version, keyName);

        if (result != LE_OK)
        {
            return result;
        }

        key = le_hashmap_Get(KeyMap[version], keyName);

        if (key == NULL)
        {
            return LE_FAULT;
        }
    }
    else
    {
        LE_DEBUG("Found key '%s' version %u.", keyName, version);
    }

    if (*keySize < key->blobSize)
    {
        LE_ERROR("Buffer overflow, unable to copy key to buffer.");
        return LE_OVERFLOW;
    }

    memcpy(keyPtr, key->blob, key->blobSize);
    *keySize = key->blobSize;

    return LE_OK;
}


//--------------------------------------------------------------------------------------------------
/**
 * Check whether the key is valid.
 *
 * @return
 *      true if key is valid, false otherwise.
 */
//--------------------------------------------------------------------------------------------------
static bool IsKeyValid
(
    le_secStore_Version_t version,      ///< [IN] Secure Storage version.
    Key_t *keyPtr                       ///< [IN] Pointer to the Key structure.
)
{
    le_result_t result = LE_FAULT;
    uint8_t plainBuf[4] = {0};
    uint8_t encryptedBuf[128];  // must accomodate the encryption overhead
    uint32_t encryptedBufSize = sizeof(encryptedBuf);

    // Check whether the key can encrypt a small data array
#if LE_CONFIG_SECSTORE_IKS_BACKEND
    if (version == LE_SECSTORE_VERSION_IKS)
    {
        // First check if the key blob size is what is expected to be for IKS case
        if (keyPtr->blobSize != KM_MAX_KEY_SIZE)
        {
            return false;
        }
        // Do the test encryption of the small buffer.
        result = iksCrypto_EncryptData(keyPtr->blob, keyPtr->blobSize,
                                       (uint8_t*)plainBuf, sizeof(plainBuf),
                                       encryptedBuf, &encryptedBufSize);
    }
#endif
#if LE_CONFIG_LINUX
    if (version == LE_SECSTORE_VERSION_TZ)
    {
        // Do the test encryption of the small buffer.
        result = tz_EncryptData(keyPtr->blob, keyPtr->blobSize,
                                (uint8_t*)plainBuf, sizeof(plainBuf),
                                encryptedBuf, &encryptedBufSize);
    }
#endif
    if (result != LE_OK)
    {
        LE_INFO("Key '%s' not valid for SecStore version %u: %s", keyPtr->name, version,
                LE_RESULT_TXT(result));
    }

    return (result == LE_OK);
}


//--------------------------------------------------------------------------------------------------
/**
 * Clean up in a situation of corrupted/invalid/compromized keys.
 *
 * @return
 *      LE_OK if successful.
 *      LE_FAULT if there was error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t ResetKeys
(
    le_secStore_Version_t version,  ///< [IN] Secure Storage version.
    bool deleteFile                 ///< [IN] Whether the keys file needs to be deleted.
)
{
    le_hashmap_Ref_t map = KeyMap[version];
    // free all keys and empty the map
    LE_INFO("Resetting keys: version %u", version);
    le_hashmap_It_Ref_t iter = le_hashmap_GetIterator(map);
    while (le_hashmap_NextNode(iter) == LE_OK)
    {
        Key_t* key = le_hashmap_GetValue(iter);
        le_hashmap_Remove(map, key->name);
        le_mem_Release(key);
    }

    // if required, delete the key file
    if (deleteFile)
    {
        LE_INFO("Deleting the key file.");
        le_result_t result = le_atomFile_Delete(KEY_FILE);
        if (result != LE_OK)
        {
            LE_ERROR("Error deleting key file");
            return LE_FAULT;
        }
    }

    return LE_OK;
}


//--------------------------------------------------------------------------------------------------
/**
 * Imports key objects from a file into a hash map.
 *
 * @return
 *      LE_OK if successful.
 *      LE_UNAVAILABLE if the sfs is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t ImportKey
(
    le_secStore_Version_t version,  ///< [IN] Secure Storage version.
    le_hashmap_Ref_t map            ///< [IN] The hash map to import the meta data to.
)
{

    LE_DEBUG("Importing keys: vers %u", version);
    // check if version is valid
    if ((version != LE_SECSTORE_VERSION_TZ) && (version != LE_SECSTORE_VERSION_IKS))
    {
        LE_ERROR("Wrong SecStore version: %u", version);
        return LE_FAULT;
    }

    // Check content of file
    int fd = le_atomFile_Create(KEY_FILE,
                                LE_FLOCK_READ,
                                LE_FLOCK_OPEN_IF_EXIST,
                                S_IRWXU);

    if (fd < 0)
    {
        LE_ERROR("Error opening keys.");
        le_atomFile_Cancel(fd);
        return LE_FAULT;
    }

    size_t dataRead = 0;

    Key_t* key;
    while (1)
    {
        key = le_mem_ForceAlloc(KeyPool);
        memset(key, 0, sizeof(*key));
        dataRead = le_fd_Read(fd, key->name, sizeof(key->name));
        if (dataRead != sizeof(key->name))
        {
            goto handleReadError;
        }

        dataRead = le_fd_Read(fd, &key->blobSize, sizeof(uint32_t));
        if (dataRead != sizeof(uint32_t))
        {
            goto handleReadError;
        }

        dataRead = le_fd_Read(fd, key->blob, sizeof(key->blob));
        if (dataRead != sizeof(key->blob))
        {
            goto handleReadError;
        }
        if (IsKeyValid(version, key))
        {
            LE_DEBUG("Importing key [%s] size %d vers %u: is valid", (char*)key->name,
                     key->blobSize, version);
            le_hashmap_Put(map, key->name, key);
        }
        else
        {
            LE_ERROR("Invalid key [%s] size %d vers %u", (char*)key->name,
                     key->blobSize, version);
            goto handleReadError;
        }
    }

handleReadError:
    if (dataRead == 0)
    {
        LE_DEBUG("Importing keys successful.");
        le_atomFile_Close(fd);
    }
    else
    {
        LE_DEBUG("Error reading keys.");
        le_mem_Release(key);
        le_atomFile_Close(fd);
        return LE_FAULT;
    }

    return LE_OK;
}

/**-----------------------------------------------------------------------------------------------
 *
 * Encrypt the data using the method specified by the version parameter.
 *
 * @return
 *      - LE_OK
 *      - LE_OVERFLOW
 *      - LE_FAULT
 */
//--------------------------------------------------------------------------------------------------
static le_result_t EncryptData
(
    le_secStore_Version_t version,      ///< [IN] Secure Storage version.
    const char* keyName,                ///< [IN] Name of the key.
    uint8_t* plainDataPtr,              ///< [IN] Plain text.
    uint32_t plainDataSize,             ///< [IN] Size of plain text.
    uint8_t* encryptedDataPtr,          ///< [IN/OUT] Encrypted data.
    uint32_t* encryptedDataSizePtr      ///< [IN/OUT] Size of encrypted data.
)
{
    // Get key
    uint8_t key[KM_MAX_KEY_SIZE];
    uint32_t keySize = sizeof(key);

    LE_DEBUG("Encrypting data: key %s vers %u size %" PRIu32, keyName, version, plainDataSize);
    le_result_t result = GetKey(version, keyName, key, &keySize);

    if (result != LE_OK)
    {
        LE_ERROR("Unable to get key.");
        return LE_FAULT;
    }

    result = LE_FAULT;
#if LE_CONFIG_SECSTORE_IKS_BACKEND
    if (version == LE_SECSTORE_VERSION_IKS)
    {
        result = iksCrypto_EncryptData(key, keySize,
                                       plainDataPtr, plainDataSize,
                                       encryptedDataPtr, encryptedDataSizePtr);
    }
#endif
#if LE_CONFIG_LINUX
    if (version == LE_SECSTORE_VERSION_TZ)
    {
        result = tz_EncryptData(key, keySize,
                                plainDataPtr, plainDataSize,
                                encryptedDataPtr, encryptedDataSizePtr);
    }
#endif
    if (result != LE_OK)
    {
        LE_ERROR("Unable to encrypt: vers %u rc %s size %"PRIuS, version,
                 LE_RESULT_TXT(result), plainDataSize);
    }

    return result;
}

//--------------------------------------------------------------------------------------------------
/**
 * Generates or uses an existing key to encrypt buffered data. The path and encrypted data is then
 * stored into the configTree.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NO_MEMORY if there is not enough memory to store the data.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_BAD_PARAMETER if the path cannot be written to because it is a directory or it would
 *                       result in an invalid path.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t Write
(
    le_secStore_Version_t version,      ///< [IN] Secure Storage version.
    const char* keyName,                ///< [IN] Name of the key. Can be NULL if data is
                                        ///<      already encrypted.
    const char* pathPtr,                ///< [IN] Path to write to.
    const uint8_t* bufPtr,              ///< [IN] Buffer containing the data.
    size_t bufSize,                     ///< [IN] Size of buffered data.
    bool isEncrypted,                   ///< [IN] Is buffered data encrypted
    le_cfg_IteratorRef_t iterRef        ///< [IN] Optional cfg iterator for write. If NULL, create
                                        ///       a new one and do not commit.
)
{
    // Encrypt the data
    uint8_t* encryptedBuf = le_mem_ForceAlloc(EncryptedBufferPool);
    uint32_t encryptedBufSize = MAX_ENCRYPTED_DATA_BYTES;
    le_cfg_IteratorRef_t iteratorRef = iterRef;
    le_result_t result = LE_OK;

    // When we copy data from one system index to another, the buffered data
    // is already encrypted. We are just writing the data to another path.
    if ((!isEncrypted) && (bufSize != 0))
    {
        result = EncryptData(version, keyName,
                             (uint8_t*) bufPtr,
                             bufSize,
                             encryptedBuf,
                             &encryptedBufSize);

        if (result != LE_OK)
        {
            LE_ERROR("Error encrypting data");
            goto exit;
        }
    }

    // Create a new write iterator
    if (iteratorRef == NULL)
    {
        iteratorRef = le_cfg_CreateWriteTxn(CFG_SECSTORE);
    }

    if ((!isEncrypted) && (bufSize != 0))
    {
        le_cfg_SetBinary(iteratorRef, pathPtr, encryptedBuf, encryptedBufSize);
    }
    else
    {
        if (bufSize != 0)
        {
            le_cfg_SetBinary(iteratorRef, pathPtr, bufPtr, bufSize);
        }
        else
        {
            // Special case of 0-size buffer, the data will be empty
            le_cfg_SetBinary(iteratorRef, pathPtr, (const uint8_t*)"", 0);
        }
    }

    // Do not commit, allow the entity that manages the iterator to do it.
    if (iterRef == NULL)
    {
        le_cfg_CommitTxn(iteratorRef);
    }

exit:
    le_mem_Release(encryptedBuf);
    return result;
}

/**-----------------------------------------------------------------------------------------------
 *
 * Decrypt encrypted data using the method specified by the version parameter.
 *
 * @return
 *      - LE_OK
 *      - LE_OVERFLOW
 *      - LE_FAULT
 */
//--------------------------------------------------------------------------------------------------
static le_result_t DecryptData
(
    le_secStore_Version_t version,      ///< [IN] Secure Storage version.
    const char* keyName,                ///< [IN] Name of the key.
    uint8_t* encryptedDataPtr,          ///< [IN] Encrypted data.
    size_t encryptedDataSize,           ///< [IN] Size of encrypted data.
    uint8_t* decryptedDataPtr,          ///< [IN/OUT] Decrypted data.
    size_t* decryptedDataSize           ///< [IN/OUT] Size of decrypted data.
)
{
    uint8_t key[KM_MAX_KEY_SIZE];
    uint32_t keySize = sizeof(key);
    le_result_t result;

    result = GetKey(version, keyName, key, &keySize);

    if (result != LE_OK)
    {
        LE_ERROR("Unable to get key %s: result %s", keyName, LE_RESULT_TXT(result));
        return result;
    }

    result = LE_FAULT;
#if LE_CONFIG_SECSTORE_IKS_BACKEND
    if (version == LE_SECSTORE_VERSION_IKS)
    {
        result = iksCrypto_DecryptData(key, keySize,
                                       encryptedDataPtr, encryptedDataSize,
                                       decryptedDataPtr, decryptedDataSize);
    }
#endif
#if LE_CONFIG_LINUX
    if (version == LE_SECSTORE_VERSION_TZ)
    {
        result = tz_DecryptData(key, keySize,
                                encryptedDataPtr, encryptedDataSize,
                                decryptedDataPtr, decryptedDataSize);
    }
#endif
    if (result != LE_OK)
    {
        LE_ERROR("Unable to decrypt: vers %u rc %s size %"PRIuS, version,
                 LE_RESULT_TXT(result), encryptedDataSize);
    }

    return result;
}

//--------------------------------------------------------------------------------------------------
/**
 * Searches configTree for encrypted data stored for a specific path. The encrypted data is
 * decrypted using an existing key and returned to the user.
 *
 *      LE_OK if successful.
 *      LE_OVERFLOW if the buffer is too small to hold all the data.  No data will be written to the
 *                  buffer in this case.
 *      LE_NOT_FOUND if the path is empty.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t ConfigTreeRead
(
    le_secStore_Version_t version,  ///< [IN] Secure Storage version.
    const char* keyName,            ///< [IN] Name of the key.
    const char* pathPtr,            ///< [IN] Path to read from.
    uint8_t* bufPtr,                ///< [IN/OUT] Buffer stored in the path.
    size_t* bufSizePtr              ///< [IN/OUT] Size of buffer stored in the path.
)
{
    LE_UNUSED(version);
    le_result_t result = LE_OK;
    le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateReadTxn(CFG_SECSTORE);
    uint8_t* encryptedData = le_mem_ForceAlloc(EncryptedBufferPool);
    uint32_t encryptedDataSize = MAX_ENCRYPTED_DATA_BYTES;
    uint8_t byte = 0;

    if (!le_cfg_NodeExists(iteratorRef, pathPtr))
    {
        LE_WARN("Node not exist!! '%s'", pathPtr);
        result = LE_NOT_FOUND;
    }
    else
    {
        result = le_cfg_GetBinary(iteratorRef,
                                  pathPtr,
                                  encryptedData,
                                  &encryptedDataSize,
                                  &byte,
                                  sizeof(byte));
        if (result != LE_OK)
        {
            LE_ERROR("Failed to get binary [%s].", pathPtr);
            goto exit;
        }

        // Manage case where the data is empty
        if (encryptedDataSize == 0)
        {
            memset(bufPtr, 0, *bufSizePtr);
            *bufSizePtr = 0;
        }
        else
        {
            result = DecryptData(version, keyName, encryptedData, encryptedDataSize,
                                 bufPtr, bufSizePtr);
            if (result != LE_OK)
            {
                LE_ERROR("Unable to decrypt: vers %u rc %s path [%s]", version,
                         LE_RESULT_TXT(result), pathPtr);
            }
        }
    }

exit:
    le_cfg_CancelTxn(iteratorRef);
    le_mem_Release(encryptedData);
    return result;
}

//--------------------------------------------------------------------------------------------------
/**
 * Searches configTree for encrypted data stored for a specific path. The encrypted data is
 * decrypted using an existing key and returned to the user.
 *
 *      LE_OK if successful.
 *      LE_OVERFLOW if the buffer is too small to hold all the data.  No data will be written to the
 *                  buffer in this case.
 *      LE_NOT_FOUND if the path is empty.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t Read
(
    le_secStore_Version_t version,  ///< [IN] Secure Storage version.
    const char* keyName,            ///< [IN] Name of the key.
    const char* pathPtr,            ///< [IN] Path to read from.
    uint8_t* bufPtr,                ///< [IN/OUT] Buffer stored in the path.
    size_t* bufSizePtr              ///< [IN/OUT] Size of buffer stored in the path.
)
{
    LE_DEBUG("Reading data: path '%s' vers %u", pathPtr, version);
    switch (version)
    {
        case LE_SECSTORE_VERSION_SFS:
            return sfsSecStore_Read(pathPtr, bufPtr, bufSizePtr);
        case LE_SECSTORE_VERSION_TZ:
        case LE_SECSTORE_VERSION_IKS:
            return ConfigTreeRead(version, keyName, pathPtr, bufPtr, bufSizePtr);
        default:
            break;
    }
    LE_ERROR("Unsupported SecStore version");
    return LE_UNAVAILABLE;
}

//--------------------------------------------------------------------------------------------------
/**
 * Deletes the path entry from the configTree.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t Delete
(
    const char* pathPtr    ///< [IN] Path to delete.
)
{
    le_result_t result = LE_OK;
    le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateWriteTxn(CFG_SECSTORE);

    if (!le_cfg_NodeExists(iteratorRef, pathPtr))
    {
        le_cfg_CancelTxn(iteratorRef);
        result = LE_NOT_FOUND;
    }
    else
    {
        le_cfg_DeleteNode(iteratorRef, pathPtr);
        le_cfg_CommitTxn(iteratorRef);
    }

    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Recursively go through all the paths under the specified iterator, to calculate the total size
 * used to store data, and collect the meta data.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t IteratePathSize
(
    le_cfg_IteratorRef_t iteratorRef, ///< [IN] Iterate through all paths under this iterator.
    size_t isRoot,                    ///< [IN] Used to mark the current iterator as root
                                      ///       so we don't iterate the roots node siblings.
    size_t* totalSizePtr,             ///< [IN/OUT] Total size of all data under the specified
                                      ///           iterator. Ignored if NULL.
    int metaFile                      ///< [IN] File to write meta data to. Ignored if -1.
)
{
    le_result_t result = LE_OK;
    static char path[LE_CFG_STR_LEN_BYTES] = "";
    uint8_t *encryptedData = NULL;
    uint8_t *buffer = NULL;
    do
    {
        // Get node type
        le_cfg_nodeType_t type = le_cfg_GetNodeType(iteratorRef, "");

        switch (type)
        {
            // A stem node, recruse into the stem's sub-items.
            case LE_CFG_TYPE_STEM:
                le_cfg_GoToFirstChild(iteratorRef);
                result = IteratePathSize(iteratorRef, false, totalSizePtr, metaFile);
                if (result != LE_OK)
                {
                    return result;
                }

                le_cfg_GoToParent(iteratorRef);

                if (isRoot)
                {
                    return result;
                }
                break;
            case LE_CFG_TYPE_EMPTY:
                break;
            default:
                le_cfg_GetPath(iteratorRef, "", path, sizeof(path));
                if (!encryptedData)
                {
                    encryptedData = le_mem_ForceAlloc(EncryptedBufferPool);
                }
                uint32_t encryptedDataSize = MAX_ENCRYPTED_DATA_BYTES;
                uint8_t byte = 0;

                result = le_cfg_GetBinary(iteratorRef,
                                          "",
                                          encryptedData,
                                          &encryptedDataSize,
                                          &byte,
                                          sizeof(byte));
                if (result != LE_OK)
                {
                    LE_ERROR("Failed to get binary");
                    result = LE_NOT_FOUND;
                    goto exit;
                }

                if (!buffer)
                {
                    buffer = le_mem_ForceAlloc(EncryptedBufferPool);
                }
                uint32_t bufferSize = MAX_ENCRYPTED_DATA_BYTES;

                // Manage case where the data is empty
                if (encryptedDataSize == 0)
                {
                    bufferSize = 0;
                }
                else
                {
                    // Identify key name for this path
                    char keyName[LIMIT_MAX_APP_NAME_BYTES];
                    PathType_t type = GetPathType(path);
                    if ((type == PATH_TYPE_AVMS_PATH) ||
                        (type == PATH_TYPE_APP_PATH))
                    {
                        result = GetApplicationName(path, keyName, sizeof(keyName));

                        if (result != LE_OK)
                        {
                            goto exit;
                        }
                    }
                    else
                    {
                        le_utf8_Copy(keyName, CFG_SECSTORE_USER_PATH, sizeof(keyName), NULL);
                    }

                    result = DecryptData(CURRENT_SECSTORE_VERSION, keyName,
                                         encryptedData, encryptedDataSize,
                                         buffer, &bufferSize);
                    // If the data can't be decrypted (due to lost key file as a result of Legato
                    // downgrade), use the encrypted size in calculations and return OK.
                    // This will allow Write() operation to succeed and overwrite the bad data.
                    if (result != LE_OK)
                    {
                        LE_WARN("Unable to decrypt [%s].", path);
                        bufferSize = encryptedDataSize;
                        result = LE_OK;
                    }
                }

                LE_DEBUG("Path: %s [size: %d]", path, bufferSize);
                if (metaFile > 0)
                {
                    char buffer[16];

                    // meta data written in the way partially compatible with old "meta file":
                    // lines 1,3,5,.. contain path, lines 2,4,6,.. contain item size.
                    le_fd_Write(metaFile, path, strnlen(path, sizeof(path)));
                    snprintf(buffer, sizeof(buffer), "\n%d\n", bufferSize);
                    le_fd_Write(metaFile, buffer, strnlen(buffer, sizeof(buffer)));
                }
                if (NULL != totalSizePtr)
                {
                    *totalSizePtr += bufferSize;
                }

                if (isRoot)
                {
                    goto exit;
                }

                break;
        }
    }
    while (le_cfg_GoToNextSibling(iteratorRef) == LE_OK);

exit:
    if (buffer)
    {
        le_mem_Release(buffer);
    }
    if (encryptedData)
    {
        le_mem_Release(encryptedData);
    }
    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Iterate through the configTree to find all data paths that are equivalent or subpaths.
 * Decrypt the data and for all the paths and return the total size.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t GetSize
(
    const char* pathPtr, ///< [IN] Path to get size.
    size_t* sizePtr      ///< [IN/OUT] Size of path.
)
{
    // Determine storage path
    le_result_t result = LE_OK;
    le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateReadTxn(CFG_SECSTORE);
    le_cfg_GoToNode(iteratorRef, pathPtr);

    if (!le_cfg_NodeExists(iteratorRef, ""))
    {
        result = LE_NOT_FOUND;
    }
    else
    {
        result = IteratePathSize(iteratorRef, true, sizePtr, -1);
    }

    le_cfg_CancelTxn(iteratorRef);
    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Copy modem SFS meta data to a specified path location.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t ModemCopyMetaTo
(
    const char* pathPtr
)
{
    LE_DEBUG("Copy meta data from modem secure storage [%s]", pathPtr);

    return sfsSecStore_CopyMetaTo(pathPtr);
}



//--------------------------------------------------------------------------------------------------
/**
 * Reads a line of text from the stream up to the first newline or eof.  The output buffer will
 * always be NULL-terminated and will not include the newline.
 *
 * @return
 *      LE_OK if successful.
 *      LE_FAULT if an error occured reading from the file.
 *      LE_OVERFLOW if the buffer is too small.  As much of the line as possible will be copied to
 *                  buf.
 *      LE_OUT_OF_RANGE if there is nothing else to read from the file.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t ReadLine
(
    int fd,                     ///< [IN] File descriptor to read from.
    char* bufPtr,               ///< [OUT] Buffer to store the line in.
    size_t bufSize              ///< [IN] Buffer size.
)
{
    char *startBufPtr = bufPtr;
    char nextChar = '\0';
    ssize_t readCount = -1;

    while (bufSize > 1)
    {
        readCount = le_fd_Read(fd, &nextChar, 1);

        if (!readCount)
        {
            if (startBufPtr == bufPtr)
            {
                return LE_OUT_OF_RANGE;
            }
            else
            {
                return LE_OK;
            }
        }
        else if (readCount < 0)
        {
            return LE_FAULT;
        }

        switch (nextChar)
        {
            case '\0':
            case '\n':
                *bufPtr = '\0';
                return LE_OK;
            default:
                *bufPtr = nextChar;
                bufPtr++;
                bufSize--;
        }
    }

    // Reached the end of the buffer without reading the end of the line.
    *bufPtr = '\0';
    return LE_OVERFLOW;
}


//--------------------------------------------------------------------------------------------------
/**
 * Reads each path from the meta file that represents all the existing paths in the modem secure
 * storage. For each path in the modem secure storage, we will extract the data from those paths
 * in the modem and re-write them into our new sfs location (configTree).
 *
 * @return
 *      LE_OK if successful.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t CopySfsFromMeta
(
    const char* metaFilePtr
)
{
    // Read the file to get the meta data.
    int file = -1;
    le_result_t result = LE_OK;

    do
    {
        file = le_atomFile_Open(metaFilePtr, LE_FLOCK_READ);
    }
    while ((file < 0) && (errno == EINTR));

    // If file doesn't exist
    if (file < 0)
    {
        LE_ERROR("Meta file %s does not exist.  (errno=%d)", metaFilePtr, errno);
        le_atomFile_Cancel(file);
        return LE_FAULT;
    }

    // Read the path and sfs names from the meta file.
    while (1)
    {
        // Read the path.
        char path[SECSTOREADMIN_MAX_PATH_BYTES];

        result = ReadLine(file, path, sizeof(path));

        if (result == LE_OUT_OF_RANGE)
        {
            break;
        }

        if (result != LE_OK)
        {
            LE_CRIT("Error (%d) reading '%s...'.", result, path);
            goto handleMetaCorruption;
        }

        // Read the sfs name
        char sfsName[LE_SECSTORE_MAX_NAME_BYTES];
        result = ReadLine(file, sfsName, sizeof(sfsName));

        if (result != LE_OK)
        {
            if (result == LE_OVERFLOW)
            {
                LE_CRIT("sfs name '%s...' is too long.", sfsName);
            }
            else
            {
                LE_CRIT("Unexpected end of meta file.");
            }
            goto handleMetaCorruption;
        }

        // Read this data from modem sfs and write to new location
        uint8_t sfsData[LE_SECSTORE_MAX_ITEM_SIZE];
        size_t sfsDataSize = sizeof(sfsData);
        result = Read(LE_SECSTORE_VERSION_SFS, NULL, path, sfsData, &sfsDataSize);

        if (result != LE_OK)
        {
            goto handleMetaCorruption;
        }

        char appName[LIMIT_MAX_APP_NAME_BYTES];
        PathType_t type = GetPathType(path);
        if (type == PATH_TYPE_APP_PATH)
        {
            result = GetApplicationName(path, appName, sizeof(appName));

            if (result != LE_OK)
            {
                goto handleMetaCorruption;
            }
        }
        else
        {
            le_utf8_Copy(appName, CFG_SECSTORE_USER_PATH, sizeof(appName), NULL);
        }

        result = Write(CURRENT_SECSTORE_VERSION, appName, path, sfsData, sfsDataSize, false, NULL);

        if (result != LE_OK)
        {
            goto handleMetaCorruption;
        }

        LE_DEBUG("Migrated [%s] successfully to new SFS.", path);
    }

    le_atomFile_Close(file);

    return LE_OK;

handleMetaCorruption:
    LE_ERROR("Meta data import failed");
    le_atomFile_Cancel(file);

    return LE_FAULT;
}

#if LE_CONFIG_LINUX
//--------------------------------------------------------------------------------------------------
/**
 * Port a data entry from one SecStore version to another.
 */
//--------------------------------------------------------------------------------------------------
static void PortDataEntry
(
    const char* entryPathPtr,   ///< [IN] Entry path
    const char* entryPtr,       ///< [IN] Entry name
    bool isDir,                 ///< [IN] true if the entry is a directory, otherwise entry is a
                                ///       file.
    void* contextPtr            ///< [IN] Context pointer.
)
{
    le_result_t result;
    EntryContext_t *entryCtxPtr = (EntryContext_t *) contextPtr;

    le_secStore_Version_t oldVersion = entryCtxPtr->version;
    LE_DEBUG("Porting entry from: version %u path '%s'", oldVersion, entryPathPtr);

    char appName[LIMIT_MAX_APP_NAME_BYTES];
    PathType_t type = GetPathType(entryPathPtr);
    if ((type == PATH_TYPE_AVMS_PATH) ||
        (type == PATH_TYPE_APP_PATH))
    {
        result = GetApplicationName(entryPathPtr, appName, sizeof(appName));
        if (result != LE_OK)
        {
            LE_ERROR("Error getting app name");
            return;
        }
    }
    else
    {
        le_utf8_Copy(appName, CFG_SECSTORE_USER_PATH, sizeof(appName), NULL);
    }

    uint8_t sfsData[LE_SECSTORE_MAX_ITEM_SIZE];
    size_t sfsDataSize = sizeof(sfsData);
    result = Read(oldVersion, appName, entryPathPtr, sfsData, &sfsDataSize);
    if (LE_OK != result)
    {
        LE_ERROR("Read error: %s path '%s' vers %u", LE_RESULT_TXT(result), entryPathPtr,
                 oldVersion);
        return;
    }

    result = Write(CURRENT_SECSTORE_VERSION, appName, entryPathPtr, sfsData, sfsDataSize,
                   false, entryCtxPtr->writeIter);
    if (result != LE_OK)
    {
        LE_ERROR("Error writing entry '%s' size %" PRIuS " app %s",
                 entryPathPtr, sfsDataSize, appName);
    }
}
#endif // LE_CONFIG_LINUX

//--------------------------------------------------------------------------------------------------
/**
 * Port data from the previous version of the Secure Storage.
 *
 * @return
 *      true if data is ported.
 *      false otherwise.
 */
//--------------------------------------------------------------------------------------------------
static bool PortDataFrom
(
    le_secStore_Version_t version
)
{
    le_result_t result = LE_FAULT;

    LE_INFO("Attempt to port data from version %u", version);
    if (version == LE_SECSTORE_VERSION_TZ)
    {
#if LE_CONFIG_LINUX
        if (KeyMap[version] == NULL)
        {
            KeyMap[version] = le_hashmap_Create("SecStoreKeysLegacy",
                                                ESTIMATED_MAX_KEYS,
                                                le_hashmap_HashString,
                                                le_hashmap_EqualsString);
        }
        // Port old TrustZone-encrypted data.
        // Load the legacy keys
        LE_INFO("Importing legacy keys");
        result = ImportKey(version, KeyMap[version]);
        if (result != LE_OK)
        {
            LE_ERROR("Key file is not valid for TrustZone encryption");
            return false;
        }
        else
        {
            LE_INFO("Legacy keys imported successfully");
        }

        // Initialize/Reset the current keys
        ResetKeys(CURRENT_SECSTORE_VERSION, true);

        // Iterate through entries
        EntryContext_t entryCtx;
        entryCtx.version = version;
        entryCtx.writeIter = le_cfg_CreateWriteTxn(CFG_SECSTORE);
        le_cfg_GoToNode(entryCtx.writeIter, "");
        result = pa_secStore_GetEntries("", PortDataEntry, (void *) &entryCtx);
        le_cfg_CommitTxn(entryCtx.writeIter);

        // Clear the legacy key map: it's not needed anymore. Don't delete the file,
        // because it's already populated with new keys.
        ResetKeys(version, false);

        LE_INFO("Porting data from TrustZone: result %s", LE_RESULT_TXT(result));
        return (result == LE_OK);
#else
        LE_INFO("TrustZone driver encryption is not available on non-Linux platforms");
        return false;
#endif // LE_CONFIG_LINUX
    }
    if (version <= LE_SECSTORE_VERSION_SFS)
    {
        // Port old secure storage data from modem SFS.
        // SFS meta data can come from two different sources: modem or FS. This will
        // manage both cases depending on the upgrade path.
        struct stat buffer;
        int isSfsV2 = stat(META_FILE, &buffer);

        LE_INFO("Porting data from SFS: isSfsV2=%d", isSfsV2);
        if (isSfsV2 != 0)
        {
            // Need to pull meta data out of the modem first
            result = ModemCopyMetaTo(TMP_META_FILE);

            if (result != LE_OK)
            {
                LE_ERROR("Failed to copy meta data to %s", TMP_META_FILE);
            }

            result = CopySfsFromMeta(TMP_META_FILE);
        }
        else
        {
            result = CopySfsFromMeta(META_FILE);
        }

        LE_INFO("Porting data from SFS: result %s", LE_RESULT_TXT(result));
        return (result == LE_OK);
    }

    LE_FATAL("Invalid version to port from!");
    return false;
}

//--------------------------------------------------------------------------------------------------
/**
 * Initialize the Secure Storage if it is not already initialized.
 *
 * @note
 *      This should be called each time the sfs is accessed to ensure SecStore is ready for use.
 *
 * @return
 *      LE_OK if successful.
 *      LE_UNAVAILABLE if currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t InitSecStore
(
    void
)
{
    le_result_t result = LE_OK;
    if (!SfsReady)
    {
        LE_DEBUG("Initializing storage: curr version %u", CURRENT_SECSTORE_VERSION);
        SfsReady = true;

        le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateReadTxn(CFG_SECSTORE);
        bool isPorted = le_cfg_GetBool(iteratorRef, "isPorted", false);
        le_cfg_CancelTxn(iteratorRef);
        LE_DEBUG("Retrieved isPorted: %d", isPorted);

        // Import encryption keys (and check them for validity)
        result = ImportKey(CURRENT_SECSTORE_VERSION, KeyMap[CURRENT_SECSTORE_VERSION]);
        if (result != LE_OK)
        {
            // Just in case: clear the key map
            le_hashmap_It_Ref_t iter = le_hashmap_GetIterator(KeyMap[CURRENT_SECSTORE_VERSION]);
            while (le_hashmap_NextNode(iter) == LE_OK)
            {
                Key_t* key = le_hashmap_GetValue(iter);
                le_hashmap_Remove(KeyMap[CURRENT_SECSTORE_VERSION], key->name);
                le_mem_Release(key);
            }
            LE_INFO("Key file is not valid for current vesion of SecStore (%u)",
                    CURRENT_SECSTORE_VERSION);
            isPorted = false;
        }
        if (!isPorted)
        {
            LE_INFO("Porting old SecStore data.");
            int version;

            // Go down the version sequence (from previous to older), try to port the data
            for (version = (int) CURRENT_SECSTORE_VERSION - 1;
                 version >= (int) LE_SECSTORE_VERSION_SFS;
                 version --)
            {
                if (PortDataFrom((le_secStore_Version_t) version))
                {
                    // if porting data from version N is successful, no need to port it
                    // from the version (N-1)
                    isPorted = true;
                    break;
                }
            }
            if (isPorted)
            {
                LE_INFO("Data successfully ported from %s",
                        version == (int) LE_SECSTORE_VERSION_TZ ? "TZ" : "SFS");
                le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateWriteTxn(CFG_SECSTORE);
                le_cfg_SetBool(iteratorRef, "isPorted", true);
                le_cfg_CommitTxn(iteratorRef);
                result = LE_OK;
            }
            else
            {
                LE_WARN("Old data can't be ported");
            }
        }
        if ((KeyMap[CURRENT_SECSTORE_VERSION] == NULL)
             || le_hashmap_isEmpty(KeyMap[CURRENT_SECSTORE_VERSION]))
        {
            LE_INFO("Importing current keys");
            result = ImportKey(CURRENT_SECSTORE_VERSION, KeyMap[CURRENT_SECSTORE_VERSION]);

            if (result != LE_OK)
            {
                LE_WARN("Key file invalid, re-setting");
                ResetKeys(CURRENT_SECSTORE_VERSION, true);
            }
        }
    }

    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Writes the data in the buffer to the specified path in secure storage replacing any previously
 * written data at the same path.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NO_MEMORY if there is not enough memory to store the data.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_BAD_PARAMETER if the path cannot be written to because it is a directory or it would
 *                       result in an invalid path.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t pa_secStore_Write
(
    const char* pathPtr,            ///< [IN] Path to write to.
    const uint8_t* bufPtr,          ///< [IN] Buffer containing the data to write.
    size_t bufSize                  ///< [IN] Size of the buffer.
)
{
    LE_DEBUG("Writing: %s", pathPtr);

    // Init Secure Storage.
    le_result_t result = InitSecStore();
    if (result != LE_OK)
    {
        return result;
    }

    char appName[LIMIT_MAX_APP_NAME_BYTES];
    PathType_t type = GetPathType(pathPtr);

    // Access the modem for AVMS use cases
    if ((type == PATH_TYPE_AVMS_PATH) ||
        (type == PATH_TYPE_APP_PATH))
    {
        result = GetApplicationName(pathPtr, appName, sizeof(appName));

        if (result != LE_OK)
        {
            return result;
        }
    }
    else
    {
        le_utf8_Copy(appName, CFG_SECSTORE_USER_PATH, sizeof(appName), NULL);
    }

    return Write(CURRENT_SECSTORE_VERSION, appName, pathPtr, bufPtr, bufSize, false, NULL);
}


//--------------------------------------------------------------------------------------------------
/**
 * Reads data from the specified path in secure storage.
 *
 * @return
 *      LE_OK if successful.
 *      LE_OVERFLOW if the buffer is too small to hold all the data.  No data will be written to the
 *                  buffer in this case.
 *      LE_NOT_FOUND if the path is empty.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t pa_secStore_Read
(
    const char* pathPtr,            ///< [IN] Path to read from.
    uint8_t* bufPtr,                ///< [OUT] Buffer to store the data in.
    size_t* bufSizePtr              ///< [IN/OUT] Size of buffer when this function is called.
                                    ///          Number of bytes read when this function returns.
)
{
    LE_DEBUG("Reading: %s", pathPtr);

    // Init Secure Storage.
    le_result_t result = InitSecStore();
    if (result != LE_OK)
    {
        LE_INFO("Init returned %s", LE_RESULT_TXT(result));
        return result;
    }

    char appName[LIMIT_MAX_APP_NAME_BYTES];
    PathType_t type = GetPathType(pathPtr);

    // In the case where the path is avms, we will try reading from trustzone first.
    // If it does not exist, we will copy it from the modem sfs.
    if (type == PATH_TYPE_AVMS_PATH)
    {
        result = GetApplicationName(pathPtr, appName, sizeof(appName));

        if (result != LE_OK)
        {
            return result;
        }

        size_t bufSizeBackup = *bufSizePtr;
        result = Read(CURRENT_SECSTORE_VERSION, appName, pathPtr, bufPtr, bufSizePtr);

        if (result == LE_OK)
        {
            return result;
        }
        else
        {
            LE_INFO("TrustZone read failed... Attempting to read from modem");
            // Unsuccessful TrustZone read may have changed the output buffer size, so it needs
            // to be restored to its original value
            *bufSizePtr = bufSizeBackup;
            result = Read(LE_SECSTORE_VERSION_SFS, NULL, pathPtr, bufPtr, bufSizePtr);

            if (result != LE_OK)
            {
                LE_ERROR("Reading from modem failed");
                return result;
            }

            result = Write(CURRENT_SECSTORE_VERSION, appName, pathPtr, bufPtr, *bufSizePtr,
                           false, NULL);

#if MK_CONFIG_AVMS_USE_IOT_KEYSTORE
            if (CURRENT_SECSTORE_VERSION == LE_SECSTORE_VERSION_IKS)
            {
                // If the platform has IoTKeystore supported and enabled, the AVMS credential stored
                // in the config tree based secure storage will be migrated to IoTKeystore during
                // initialization of AVC client. Since the credential stored in modem SFS has
                // already been migrated to config tree, the credential stored in the modem SFS must
                // be deleted. Eventually, the migrated credential from config tree will also be
                // deleted during initialization of AVC client.
                if (result == LE_OK)
                {
                    result = sfsSecStore_Delete(pathPtr);
                    LE_INFO("Deleting credential from path %s on modem SFS, result = %s",
                            pathPtr, LE_RESULT_TXT(result));
                }
            }
#endif
            return result;
        }
    }
    else if (type == PATH_TYPE_APP_PATH)
    {
        result = GetApplicationName(pathPtr, appName, sizeof(appName));

        if (result != LE_OK)
        {
            return result;
        }
    }
    else
    {
        le_utf8_Copy(appName, CFG_SECSTORE_USER_PATH, sizeof(appName), NULL);
    }

    return Read(CURRENT_SECSTORE_VERSION, appName, pathPtr, bufPtr, bufSizePtr);
}


//--------------------------------------------------------------------------------------------------
/**
 * Write the meta data to the specified path.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the meta data cannot be retrieved.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t pa_secStore_CopyMetaTo
(
    const char* pathPtr             ///< [IN] Destination path of meta file copy.
)
{
    le_result_t result = LE_OK;
    int destFile = le_atomFile_Create(pathPtr, LE_FLOCK_WRITE, LE_FLOCK_REPLACE_IF_EXIST,
                                      S_IRWXU);
    if (destFile < 0)
    {
        return LE_NOT_FOUND;
    }

    le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateReadTxn(CFG_SECSTORE);

    if (!le_cfg_NodeExists(iteratorRef, ""))
    {
        result = LE_NOT_FOUND;
    }
    else
    {
        result = IteratePathSize(iteratorRef, true, NULL, destFile);
    }

    le_cfg_CancelTxn(iteratorRef);
    le_atomFile_Close(destFile);

    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Deletes the specified path and everything under it.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t pa_secStore_Delete
(
    const char* pathPtr             ///< [IN] Path to delete.
)
{
    LE_DEBUG("Deleting: %s", pathPtr);

    // Init Secure Storage.
    le_result_t result = InitSecStore();
    if (result != LE_OK)
    {
        return result;
    }

    return Delete(pathPtr);
}


//--------------------------------------------------------------------------------------------------
/**
 * Gets the size, in bytes, of the data at the specified path and everything under it.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t pa_secStore_GetSize
(
    const char* pathPtr,            ///< [IN] Path.
    size_t* sizePtr                 ///< [OUT] Size in bytes of all items in the path.
)
{
    // Init Secure Storage.
    le_result_t result = InitSecStore();
    if (result != LE_OK)
    {
        return result;
    }

    return GetSize(pathPtr, sizePtr);
}


//--------------------------------------------------------------------------------------------------
/**
 * Recursively go through all the paths under the specified iterator and call the supplied callback
 * with each entry name.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t IteratePathEntries
(
    le_cfg_IteratorRef_t iteratorRef,       ///< [IN] Path.
    bool isRoot,                            ///< [IN] Used to mark the current iterator as root
                                            ///       so we don't iterate the roots node siblings.
    const char* pathPtr,                    ///< [IN] Path.
    pa_secStore_GetEntry_t getEntryFunc,    ///< [IN] Callback function to call with each entry.
    void* contextPtr                        ///< [IN] Context to be supplied to the callback.
)
{
    le_result_t result = LE_OK;
    static char path[LE_CFG_STR_LEN_BYTES] = "";
    do
    {
        // Get node type
        le_cfg_nodeType_t type = le_cfg_GetNodeType(iteratorRef, "");

        switch (type)
        {
            // A stem node, recruse into the stem's sub-items.
            case LE_CFG_TYPE_STEM:
                le_cfg_GoToFirstChild(iteratorRef);
                result = IteratePathEntries(iteratorRef, false, pathPtr, getEntryFunc, contextPtr);
                if (result != LE_OK)
                {
                    return result;
                }

                le_cfg_GoToParent(iteratorRef);

                if (isRoot)
                {
                    return result;
                }
                break;
            case LE_CFG_TYPE_EMPTY:
                break;
            default:
                le_cfg_GetPath(iteratorRef, "", path, sizeof(path));
                size_t pathLen = strlen(pathPtr);

                // Find the entry string.
                char* entryPtr;

               if (pathPtr[pathLen-1] == '/')
                {
                    entryPtr = (char*)&(path[pathLen]);
                }
                else if (path[pathLen] == '/')
                {
                    entryPtr = (char*)&(path[pathLen + 1]);
                }
                else
                {
                    // There is no entry string, move on.
                    continue;
                }

                // Check if the entry is a directory.
                bool isDir = (strchr(entryPtr, '/') != NULL);

                // Copy the entry to a local buffer.
                char buf[512];

                LE_FATAL_IF(le_utf8_CopyUpToSubStr(buf, entryPtr, "/", sizeof(buf), NULL) != LE_OK,
                            "Buffer too small to hold entry name '%s...'.", buf);

                // Call the callback function.
                if (getEntryFunc != NULL)
                {
                    getEntryFunc(path, buf, isDir, contextPtr);
                }

                break;
        }
    }
    while (le_cfg_GoToNextSibling(iteratorRef) == LE_OK);

    return result;
}

//--------------------------------------------------------------------------------------------------
/**
 * Iterates over all entries under the specified path, calling the supplied callback
 * with each entry name.
 *
 * @return
 *      LE_OK if successful.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
LE_SHARED le_result_t pa_secStore_GetEntries
(
    const char* pathPtr,                    ///< [IN] Path.
    pa_secStore_GetEntry_t getEntryFunc,    ///< [IN] Callback function to call with each entry.
    void* contextPtr                        ///< [IN] Context to be supplied to the callback.
)
{
    // Init Secure Storage.
    le_result_t result = InitSecStore();
    if (result != LE_OK)
    {
        return result;
    }

    le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateReadTxn(CFG_SECSTORE);
    le_cfg_GoToNode(iteratorRef, pathPtr);

    if (le_cfg_NodeExists(iteratorRef, ""))
    {
        result = IteratePathEntries(iteratorRef, true, pathPtr, getEntryFunc, contextPtr);
    }

    le_cfg_CancelTxn(iteratorRef);

    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Gets the total space and the available free space in secure storage.
 *
 * @return
 *      LE_OK if successful.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t pa_secStore_GetTotalSpace
(
    size_t* totalSpacePtr,                  ///< [OUT] Total size, in bytes, of secure storage.
    size_t* freeSizePtr                     ///< [OUT] Free space, in bytes, in secure storage.
)
{
    size_t usedSize = 0;

    le_result_t result = GetSize("", &usedSize);
    if (LE_NOT_FOUND == result)
    {
        return LE_UNAVAILABLE;
    }
    else if (LE_OK != result)
    {
        return result;
    }

    *totalSpacePtr = SECSTORE_TOTAL_SPACE;
    if (*totalSpacePtr > usedSize)
    {
        *freeSizePtr = *totalSpacePtr - usedSize;
    }
    else
    {
        *freeSizePtr = 0;
    }

    return LE_OK;
}


//--------------------------------------------------------------------------------------------------
/**
 * Recursively go through all the paths under the specified iterator and copy them to a new
 * destination.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t IteratePathCopy
(
    le_cfg_IteratorRef_t iteratorRef,       ///< [IN] Path.
    bool isRoot,                            ///< [IN] Used to mark the current iterator as root
                                            ///       so we don't iterate the roots node siblings.
    const char* destPathPtr,                ///< [IN] Destination path.
    const char* srcPathPtr                  ///< [IN] Source path.
)
{
    le_result_t result = LE_OK;
    static char path[LE_CFG_STR_LEN_BYTES] = "";
    uint8_t* encryptedData = NULL;
    do
    {
        // Get node type
        le_cfg_nodeType_t type = le_cfg_GetNodeType(iteratorRef, "");

        switch (type)
        {
            // A stem node, recruse into the stem's sub-items.
            case LE_CFG_TYPE_STEM:
                le_cfg_GoToFirstChild(iteratorRef);
                result = IteratePathCopy(iteratorRef, false, destPathPtr, srcPathPtr);
                if (result != LE_OK)
                {
                    return result;
                }

                le_cfg_GoToParent(iteratorRef);

                if (isRoot)
                {
                    return result;
                }
                break;
            case LE_CFG_TYPE_EMPTY:
                break;
            default:
                le_cfg_GetPath(iteratorRef, "", path, sizeof(path));

                char destPath[LE_CFG_STR_LEN_BYTES];
                memset(destPath, 0, sizeof(destPath));
                LE_FATAL_IF(le_path_Concat("/",
                                           destPath,
                                           LE_CFG_STR_LEN_BYTES,
                                           destPathPtr,
                                           &(path[strlen(srcPathPtr)]),
                                           (void *)NULL) != LE_OK,
                                           "Dest path '%s' is too long.", destPath);

                if (!encryptedData)
                {
                    encryptedData = le_mem_ForceAlloc(EncryptedBufferPool);
                }

                uint32_t encryptedDataSize = MAX_ENCRYPTED_DATA_BYTES;
                uint8_t byte = 0;

                le_result_t result = le_cfg_GetBinary(iteratorRef,
                                                      "",
                                                      encryptedData,
                                                      &encryptedDataSize,
                                                      &byte,
                                                      sizeof(byte));
                if (result != LE_OK)
                {
                    LE_ERROR("Failed to get binary [%s]", path);
                    le_cfg_CancelTxn(iteratorRef);
                    result = LE_NOT_FOUND;
                    goto exit;
                }

                // Copy encrypted data to new path
                Write(CURRENT_SECSTORE_VERSION, NULL, destPath,
                      encryptedData, encryptedDataSize,
                      true, iteratorRef);

                LE_DEBUG("Copying %s to %s", path, destPath);

                if (isRoot)
                {
                    goto exit;
                }

                break;
        }
    }
    while (le_cfg_GoToNextSibling(iteratorRef) == LE_OK);

exit:
    if (encryptedData)
    {
        le_mem_Release(encryptedData);
    }
    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Copies all the data from source path to destination path.  The destination path must be empty.
 *
 * @return
 *      LE_OK if successful.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t pa_secStore_Copy
(
    const char* destPathPtr,                ///< [IN] Destination path.
    const char* srcPathPtr                  ///< [IN] Source path.
)
{
    // Make sure the source and dest paths don't overlap.
    if ( le_path_IsEquivalent(srcPathPtr, destPathPtr, "/") ||
         le_path_IsSubpath(srcPathPtr, destPathPtr, "/") ||
         le_path_IsSubpath(destPathPtr, srcPathPtr, "/") )
    {
        LE_ERROR("Cannot copy %s into itself.", srcPathPtr);
        return LE_FAULT;
    }

    // Init Secure Storage.
    le_result_t result = InitSecStore();
    if (result != LE_OK)
    {
        return result;
    }

    le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateWriteTxn(CFG_SECSTORE);
    le_cfg_GoToNode(iteratorRef, srcPathPtr);

    if (le_cfg_NodeExists(iteratorRef, ""))
    {
        result = IteratePathCopy(iteratorRef, true, destPathPtr, srcPathPtr);
    }

    if (result != LE_OK)
    {
        le_cfg_CancelTxn(iteratorRef);
    }
    else
    {
        le_cfg_CommitTxn(iteratorRef);
    }

    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Moves all the data from source path to destination path.  The destination path must be empty.
 * Similar to a copy but we will delete the old data since we cannot rename nodes in cfgTree.
 *
 * @return
 *      LE_OK if successful.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t pa_secStore_Move
(
    const char* destPathPtr,                ///< [IN] Destination path.
    const char* srcPathPtr                  ///< [IN] Source path.
)
{
    // Make sure the source and dest paths don't overlap.
    if ( le_path_IsEquivalent(srcPathPtr, destPathPtr, "/") ||
         le_path_IsSubpath(srcPathPtr, destPathPtr, "/") ||
         le_path_IsSubpath(destPathPtr, srcPathPtr, "/") )
    {
        LE_ERROR("Cannot move %s into itself.", srcPathPtr);
        return LE_FAULT;
    }

    // Init Secure Storage.
    le_result_t result = InitSecStore();
    if (result != LE_OK)
    {
        return result;
    }

    le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateWriteTxn(CFG_SECSTORE);
    le_cfg_GoToNode(iteratorRef, srcPathPtr);

    if (le_cfg_NodeExists(iteratorRef, ""))
    {
        result = IteratePathCopy(iteratorRef, true, destPathPtr, srcPathPtr);
    }

    if (result != LE_OK)
    {
        le_cfg_CancelTxn(iteratorRef);
    }
    else
    {
        le_cfg_CommitTxn(iteratorRef);
    }

    // Delete the node
    iteratorRef = le_cfg_CreateWriteTxn(CFG_SECSTORE);
    le_cfg_DeleteNode(iteratorRef, srcPathPtr);
    le_cfg_CommitTxn(iteratorRef);

    return LE_OK;
}


//--------------------------------------------------------------------------------------------------
/**
 * Re-initialize the secure storage if is already initialized.
 *
 * @note
 *      This should be called each time the restore done indication is received in service level,
 *      so that the meta hash can be rebuilt.
 *
 * @return
 */
//--------------------------------------------------------------------------------------------------
LE_SHARED void pa_secStore_ReInitSecStorage
(
    void
)
{
    return;
}

//--------------------------------------------------------------------------------------------------
/**
 * This function must be called to register a handler for restore event in PA level to notify
 * service level.
 */
//--------------------------------------------------------------------------------------------------
LE_SHARED le_event_HandlerRef_t pa_secStore_SetRestoreHandler
(
    pa_secStore_RestoreHdlrFunc_t handlerFuncPtr ///< [IN] The handler function.
)
{
    return NULL;
}


//--------------------------------------------------------------------------------------------------
/**
 * Init this component
 */
//--------------------------------------------------------------------------------------------------
COMPONENT_INIT
{
#if LE_CONFIG_LINUX
#if LE_CONFIG_SECSTORE_IKS_BACKEND
    // Check if TZ4 is supported before setting it as the current secStore version.
    LE_DEBUG("Checking if TZ4 is supported");
    int fd;
    fd = open(SIERRA_TZDEV4_ENABLED_PATH, O_RDONLY | O_NONBLOCK);

    if (fd != -1)
    {
        char tzEnabled[2];
        int size = read(fd, tzEnabled, sizeof(tzEnabled));
        if (size > 0)
        {
            if (strncmp(tzEnabled, "Y", 1) == 0)
            {
                LE_DEBUG("TZ4 is supported.");
                CURRENT_SECSTORE_VERSION = LE_SECSTORE_VERSION_IKS;
            }
        }
        close(fd);
    }
#endif
#else
    CURRENT_SECSTORE_VERSION = LE_SECSTORE_VERSION_SFS;
#endif
    LE_INFO("Init TZ secure storage PA [Version: %d]", CURRENT_SECSTORE_VERSION);
    KeyPool = le_mem_CreatePool("KeyNamePool", sizeof(Key_t));

    // Create memory pool to hold encrypted data contents
    EncryptedBufferPool = le_mem_InitStaticPool(EncryptedBuffer,
                                                MAX_ENCRYPTED_BUFFERS,
                                                MAX_ENCRYPTED_DATA_BYTES);

    // Create the key data hash map.
    KeyMap[CURRENT_SECSTORE_VERSION] = le_hashmap_Create("SecStoreKeys",
                                        ESTIMATED_MAX_KEYS,
                                        le_hashmap_HashString,
                                        le_hashmap_EqualsString);
}
