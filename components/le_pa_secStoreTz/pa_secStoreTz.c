/**
 * @file pa_secStoreTz.c
 *
 * TrustZone implementation of @ref c_pa_secStore API.
 *
 * This Platform Adapter implementation of the Secure Storage stores data in the configTree.
 * The data is encrypted/decrypted using the keys provided by Sierra Wireless TrustZone solution.
 *
 * A unique key is generated for each application with the name of the app and stored in a keys
 * file. The key file is protected through SMACK under the applications' appWriteable directory.
 * Paths that are not apart of an application e.g. system paths or globals, secure storage will use
 * a general user key. Keys will be used to encrypt or decrypt data.
 *
 * There are three secure storage path use cases managed:
 * | Path type                  | Details                                                        |
 * |----------------------------|----------------------------------------------------------------|
 * | AVMS Keys                  | The AVMS keys are provisioned in modem SFS. Therefore we will  |
 * |                            | need to rely on QMI to access SFS in this specific case.       |
 * |                            |                                                                |
 * | Application keys           | A new key for each unique application.                         |
 * |                            |                                                                |
 * | User key                   | Key used to manage system paths that are not application paths.|
 * |----------------------------|----------------------------------------------------------------|
 *
 * The secure storage data is stored in the following format (example):
* /
  sys/
    1/
      apps/
        test/
            secret<string> == pv9DtEVd1TVI7Dit41PEJZk/jiP+aDGlaO72YpgQrzYOwhXIVdd+vdHHla5yxhk=
      hash<string> == AUbdSg9/Z744m/UJzaGGHgrKSzcmUVnNZzc/CgjIc1G4
  isPorted<bool> == true
  global/
    file1<string> == aGGHgrK
 *
 *
 * Copyright (C) Sierra Wireless Inc.
 */

#include "legato.h"
#include "limit.h"
#include "interfaces.h"
#include "pa_secStore.h"
#include "trustZone.h"
#include "fnmatch.h"
#include <dlfcn.h>


//--------------------------------------------------------------------------------------------------
/**
 * Config path to the secure storage content.
 */
//--------------------------------------------------------------------------------------------------
#define CFG_SECSTORE            "secStore:/"
#define CFG_SECSTORE_USER_PATH  ".user" // special keyword for other non application paths


//--------------------------------------------------------------------------------------------------
/**
 * Location of the key file. This file is used to store the keys generated by TrustZone.
 */
//--------------------------------------------------------------------------------------------------
#define KEY_FILE      "keys"


//--------------------------------------------------------------------------------------------------
/**
 * Location of meta data file.  This meta data file is used to store a mapping between sfs file
 * names and user specified paths.
 */
//--------------------------------------------------------------------------------------------------
#define META_FILE                   "/legato/meta"


//--------------------------------------------------------------------------------------------------
/**
 * Temporary version of meta data file from SFS.
 */
//--------------------------------------------------------------------------------------------------
#define TMP_META_FILE               "/tmp/meta"


//--------------------------------------------------------------------------------------------------
/**
 * Index of the application name
 */
//--------------------------------------------------------------------------------------------------
#define PATH_APP_NAME_INDEX         3


//--------------------------------------------------------------------------------------------------
/**
 * Max size of encrypted data.
 */
//--------------------------------------------------------------------------------------------------
#define MAX_ENCRYPTED_DATA_BYTES    12288


//--------------------------------------------------------------------------------------------------
/**
 * Total available space of the secure storage, in bytes.
 * It's not enforced, but needed to return some number from GetTotalSpace() API.
 */
//--------------------------------------------------------------------------------------------------
#define SECSTORE_TOTAL_SPACE        (1024 * 1024)


//--------------------------------------------------------------------------------------------------
/**
 * Flag to indicate if the sfs is ready for user access.
 */
//--------------------------------------------------------------------------------------------------
static bool SfsReady = false;


//--------------------------------------------------------------------------------------------------
/**
 * Hash map of key data.
 */
//--------------------------------------------------------------------------------------------------
static le_hashmap_Ref_t KeyMap = NULL;


//--------------------------------------------------------------------------------------------------
/**
 * Estimated maximum number of keys.
 */
//--------------------------------------------------------------------------------------------------
#define ESTIMATED_MAX_KEYS             100


//--------------------------------------------------------------------------------------------------
/**
 * Memory pool of key objects
 */
//--------------------------------------------------------------------------------------------------
static le_mem_PoolRef_t KeyPool = NULL;


//--------------------------------------------------------------------------------------------------
/**
 * Path to modem secure storage PA library.
 */
//--------------------------------------------------------------------------------------------------
static const char ModemSecStorePAPath[] = "lib/libComponent_le_pa_secStore.so";


//--------------------------------------------------------------------------------------------------
/**
 * Pointer to modem secure storage PA (assuming modem PA exists).
 */
//--------------------------------------------------------------------------------------------------
static void* ModemSecStorePASoPtr;


//--------------------------------------------------------------------------------------------------
/**
 * Key object
 */
//--------------------------------------------------------------------------------------------------
typedef struct {
    char name[LIMIT_MAX_APP_NAME_BYTES];
    uint8_t blob[KM_MAX_KEY_SIZE];
    uint32_t blobSize;
}
Key_t;


//--------------------------------------------------------------------------------------------------
/**
 * SFS Path types.
 */
//--------------------------------------------------------------------------------------------------
typedef enum {
    SFS_PATH_TYPE_PATH = 0x0,        ///< A path.
    SFS_PATH_TYPE_APP_PATH = 0x1,    ///< A path that belongs to an app.
    SFS_PATH_TYPE_AVMS_PATH = 0x2,   ///< A path that belongs specifically for avms.
}
SfsPathType_t;


//--------------------------------------------------------------------------------------------------
/**
 * SFS Path object.
 */
//--------------------------------------------------------------------------------------------------
typedef struct {
    char pattern[LIMIT_MAX_APP_NAME_BYTES];
    SfsPathType_t type;
}
SfsPath_t;


//--------------------------------------------------------------------------------------------------
/**
 * SFS Paths pattern match. Used to determine how we manage different paths.
 */
//--------------------------------------------------------------------------------------------------
static SfsPath_t SfsPaths[] = {
    { "/sys/*/apps/avcService/avms/LWM2M_BOOTSTRAP*", SFS_PATH_TYPE_AVMS_PATH },
    { "/sys/*/apps/avcService/avms/LWM2M_FW_KEY", SFS_PATH_TYPE_AVMS_PATH },
    { "/sys/*/apps/avcService/avms/LWM2M_SW_KEY", SFS_PATH_TYPE_AVMS_PATH },
    { "/sys/*/apps/avcService/avms/certificate", SFS_PATH_TYPE_AVMS_PATH },
    { "/sys/*/apps/avcService/avms/bs_server_public_key", SFS_PATH_TYPE_AVMS_PATH },
    { "/sys/*/apps/*", SFS_PATH_TYPE_APP_PATH }
};


//--------------------------------------------------------------------------------------------------
/**
 * Prototype for iteratively getting entries.
 */
//--------------------------------------------------------------------------------------------------
typedef void (*pa_secStore_GetEntry_t)
(
    const char* entryPtr,           ///< [IN] Entry name.
    bool isDir,                     ///< [IN] true if the entry is a directory, otherwise entry is a
                                    ///       file.
    void* contextPtr                ///< [IN] Pointer to the context supplied to
                                    ///       pa_secStore_GetEntries()
);


//--------------------------------------------------------------------------------------------------
/**
 * Determine the path type.
 */
//--------------------------------------------------------------------------------------------------
static SfsPathType_t GetPathType
(
    const char* pathPtr
)
{
    size_t sfsPathSize = sizeof(SfsPaths) / sizeof(SfsPaths[0]);

    int i = 0;
    for (i = 0; i < sfsPathSize; i++)
    {
        if (fnmatch(SfsPaths[i].pattern, pathPtr, 0) == 0)
        {
            return SfsPaths[i].type;
        }
    }

    return SFS_PATH_TYPE_PATH;
}


//--------------------------------------------------------------------------------------------------
/**
 * Get the application name from the path.
 *
 * @return
 *      LE_OK if the application name is found.
 *      LE_NOT_FOUND if the application name is not found.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t GetApplicationName
(
    const char* pathPtr,    ///< [IN] Path.
    char* appNamePtr,       ///< [OUT] Name of the application if the path is an application path.
    size_t appNameSize      ///< [IN/OUT] Size of the application buffer.
)
{
    le_result_t result = LE_NOT_FOUND;
    le_pathIter_Ref_t iteratorRef = le_pathIter_CreateForUnix(pathPtr);

    if (le_pathIter_IsEmpty(iteratorRef))
    {
        result = LE_FAULT;
        goto out;
    }

    le_pathIter_GoToStart(iteratorRef);

    // Assume an application path is defined as the following: /sys/<index>/apps/<appName>
    int pathIterCount = 0;
    do
    {
        char buffer[LIMIT_MAX_APP_NAME_BYTES] = { 0 };
        if (le_pathIter_GetCurrentNode(iteratorRef, buffer, LIMIT_MAX_APP_NAME_BYTES) != LE_OK)
        {
            result = LE_FAULT;
            goto out;
        }

        // This should be our app name
        if (pathIterCount == PATH_APP_NAME_INDEX)
        {
            result = le_utf8_Copy(appNamePtr, buffer, appNameSize, NULL);

            if (result != LE_OK)
            {
                result = LE_FAULT;
                goto out;
            }

            result = LE_OK;
            goto out;
        }

        pathIterCount++;
    }
    while (le_pathIter_GoToNext(iteratorRef) != LE_NOT_FOUND);

    result = LE_NOT_FOUND;

out:
    le_pathIter_Delete(iteratorRef);
    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Generate a new key for a given key name. Generally the key name is the name of the application.
 * The key name, key blob and key size will be stored in a key file within the working directory
 * of the service that uses the trustZone PA. The key file is protected by smack and can only be
 * accessed by the secure storage service.
 *
 * @return
 *      LE_OK if a new key is successfully generated and stored.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t GenerateKey
(
    const char* keyName    ///< [IN] Name of the key.
)
{
    // Open the sfs file.
    FILE* fp = le_atomFile_CreateStream(KEY_FILE,
                                      LE_FLOCK_READ_AND_APPEND,
                                      LE_FLOCK_OPEN_IF_EXIST,
                                      S_IRWXU,
                                      NULL);

    if (fp == NULL)
    {
        le_atomFile_CancelStream(fp);
        LE_ERROR("Failed to open %s", KEY_FILE);
        return LE_FAULT;
    }

    Key_t* key = le_mem_ForceAlloc(KeyPool);
    le_utf8_Copy(key->name, keyName, sizeof(key->name), NULL);

    if (keyName)
    {
        // Write the path to the file.
        if (fwrite(key->name, sizeof(char), sizeof(key->name), fp) != sizeof(key->name))
        {
            goto handleWriteError;
        }

        // Generate key for this app
        key->blobSize = sizeof(key->blob);
        le_result_t result = tz_GenerateKey(key->blob, &key->blobSize);

        if (result != LE_OK)
        {
            goto handleWriteError;
        }

        if (fwrite(&key->blobSize, sizeof(uint32_t), 1, fp) != 1)
        {
           goto handleWriteError;
        }

        if (fwrite(key->blob, sizeof(uint8_t), sizeof(key->blob), fp) != sizeof(key->blob))
        {
           goto handleWriteError;
        }

        LE_DEBUG("Writing key [name: %s] [size: %d]", key->name, key->blobSize);
    }

    le_atomFile_CloseStream(fp);
    le_hashmap_Put(KeyMap, key->name, key);
    return LE_OK;

handleWriteError:
    LE_ERROR("Failed to write key data.");
    le_mem_Release(key);
    le_atomFile_CancelStream(fp);
    return LE_FAULT;
}


//--------------------------------------------------------------------------------------------------
/**
 * Get the key blob of a specific key name. Generally the key name will be the name of an app.
 * If a key does not exist for a key name, this function will generate a new one.
 *
 * @return
 *      LE_OK if a key is returned successfully.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t GetKey
(
    const char* keyName,    ///< [IN] Name of the key.
    uint8_t* keyPtr,        ///< [IN/OUT] Key blob for the specified key name.
    uint32_t* keySize       ///< [IN/OUT] Size of the key blob.
)
{
    const Key_t* key = le_hashmap_Get(KeyMap, keyName);

    if (key == NULL)
    {
        LE_DEBUG("Generating new key for: %s.", keyName);
        le_result_t result = GenerateKey(keyName);

        if (result != LE_OK)
        {
            return result;
        }

        key = le_hashmap_Get(KeyMap, keyName);

        if (key == NULL)
        {
            return LE_FAULT;
        }
    }
    else
    {
        LE_DEBUG("Key exist.");
    }

    if (*keySize < key->blobSize)
    {
        LE_ERROR("Buffer overflow, unable to copy key to buffer.");
        return LE_OVERFLOW;
    }

    memcpy(keyPtr, key->blob, key->blobSize);
    *keySize = key->blobSize;

    return LE_OK;
}


//--------------------------------------------------------------------------------------------------
/**
 * Imports key objects from a file into a hash map.
 *
 * @return
 *      LE_OK if successful.
 *      LE_UNAVAILABLE if the sfs is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t ImportKey
(
    le_hashmap_Ref_t map,           ///< [IN] The hash map to import the meta data to.
    const char* keyFilePtr          ///< [IN] Name of the file that contains the keys.
)
{
    // Check content of file
    FILE* fp = le_atomFile_CreateStream(KEY_FILE,
                                        LE_FLOCK_READ,
                                        LE_FLOCK_OPEN_IF_EXIST,
                                        S_IRWXU,
                                        NULL);

    if (fp == NULL)
    {
        LE_ERROR("Error opening keys.");
        le_atomFile_CancelStream(fp);
        return LE_FAULT;
    }

    size_t dataRead = 0;

    Key_t* key;
    while (1)
    {
        key = le_mem_ForceAlloc(KeyPool);
        dataRead = fread(key->name, sizeof(char), sizeof(key->name), fp);
        if (dataRead != sizeof(key->name))
        {
            goto handleReadError;
        }

        dataRead = fread(&key->blobSize, sizeof(uint32_t), 1, fp);
        if (dataRead != 1)
        {
            goto handleReadError;
        }

        dataRead = fread(key->blob, sizeof(uint8_t), sizeof(key->blob), fp);
        if (dataRead != sizeof(key->blob))
        {
            goto handleReadError;
        }

        LE_DEBUG("Importing key [%s] size [%d]", (char*)key->name, key->blobSize);
        le_hashmap_Put(map, key->name, key);
    }

handleReadError:
    if (dataRead == 0)
    {
        LE_DEBUG("Importing keys successful.");
        le_atomFile_CloseStream(fp);
    }
    else
    {
        LE_DEBUG("Error reading keys.");
        le_mem_Release(key);
        le_atomFile_CloseStream(fp);
        return LE_FAULT;
    }

    return LE_OK;
}


//--------------------------------------------------------------------------------------------------
/**
 * Writes the data in the buffer to the specified path in modem secure storage replacing any
 * previously written data at the same path.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NO_MEMORY if there is not enough memory to store the data.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_BAD_PARAMETER if the path cannot be written to because it is a directory or it would
 *                       result in an invalid path.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t ModemWrite
(
    const char* pathPtr,            ///< [IN] Path to write to.
    const uint8_t* bufPtr,          ///< [IN] Buffer containing the data to write.
    size_t bufSize                  ///< [IN] Size of the buffer.
)
{
    LE_DEBUG("Writing to modem secure storage [%s]", pathPtr);

    if (ModemSecStorePASoPtr == NULL)
    {
        ModemSecStorePASoPtr = dlopen(ModemSecStorePAPath, RTLD_LAZY);

        if (NULL == ModemSecStorePASoPtr)
        {
            LE_ERROR("Could not open %s.", ModemSecStorePAPath);
            LE_ERROR("%s", dlerror());
            return LE_FAULT;
        }
    }

    static int (*pa_secStore_Write)(const char*, const uint8_t*, size_t) = NULL;
    pa_secStore_Write = dlsym(ModemSecStorePASoPtr, "pa_secStore_Write");
    if (!pa_secStore_Write)
    {
        LE_WARN("Could not get function pa_secStore_Write.");
        LE_ERROR("%s", dlerror());
        return LE_FAULT;
    }

    return pa_secStore_Write(pathPtr, bufPtr, bufSize);
}


//--------------------------------------------------------------------------------------------------
/**
 * Generates or uses an existing key to encrypt buffered data. The path and encrypted data is then
 * stored into the configTree.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NO_MEMORY if there is not enough memory to store the data.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_BAD_PARAMETER if the path cannot be written to because it is a directory or it would
 *                       result in an invalid path.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t Write
(
    const char* keyName,                ///< [IN] Name of the key.
    const char* pathPtr,                ///< [IN] Path to write to.
    const uint8_t* bufPtr,              ///< [IN] Buffer containing the data.
    size_t bufSize,                     ///< [IN] Size of buffered data.
    bool isEncrypted,                   ///< [IN] Is buffered data encrypted
    le_cfg_IteratorRef_t iterRef        ///< [IN] Optional cfg iterator for write. If NULL, create
                                        ///       a new one and do not commit.
)
{
    // Get key
    uint8_t key[KM_MAX_KEY_SIZE];
    uint32_t keySize = sizeof(key);

    le_result_t result = GetKey(keyName, key, &keySize);

    if (result != LE_OK)
    {
        LE_ERROR("Unable to get key.");
        return LE_FAULT;
    }

    // Encrypt the data
    uint8_t encryptedBuf[MAX_ENCRYPTED_DATA_BYTES];
    uint32_t encryptedBufSize = sizeof(encryptedBuf);

    // When we copy data from one system index to another, the buffered data
    // is already encrypted. We are just writing the data to another path.
    if ((!isEncrypted) && (bufSize != 0))
    {
        result = tz_EncryptData(key,
                                keySize,
                                (uint8_t*)bufPtr,
                                bufSize,
                                encryptedBuf,
                                &encryptedBufSize);

        if (result != LE_OK)
        {
            LE_ERROR("Error encrypting data");
            return result;
        }
    }

    le_cfg_IteratorRef_t iteratorRef = iterRef;

    // Create a new write iterator
    if (iterRef == NULL)
    {
        iteratorRef = le_cfg_CreateWriteTxn(CFG_SECSTORE);
    }

    if ((!isEncrypted) && (bufSize != 0))
    {
        le_cfg_SetBinary(iteratorRef, pathPtr, encryptedBuf, encryptedBufSize);
    }
    else
    {
        if (bufSize != 0)
        {
            le_cfg_SetBinary(iteratorRef, pathPtr, bufPtr, bufSize);
        }
        else
        {
            // Special case of 0-size buffer, the data will be empty
            le_cfg_SetBinary(iteratorRef, pathPtr, (const uint8_t*)"", 0);
        }
    }

    // Do not commit, allow the entity that manages the iterator to do it.
    if (iterRef == NULL)
    {
        le_cfg_CommitTxn(iteratorRef);
    }

    return LE_OK;
}


//--------------------------------------------------------------------------------------------------
/**
 * Reads data from the specified path in modem secure storage.
 *
 * @return
 *      LE_OK if successful.
 *      LE_OVERFLOW if the buffer is too small to hold all the data.  No data will be written to the
 *                  buffer in this case.
 *      LE_NOT_FOUND if the path is empty.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t ModemRead
(
    const char* pathPtr,            ///< [IN] Path to read from.
    uint8_t* bufPtr,                ///< [OUT] Buffer to store the data in.
    size_t* bufSizePtr              ///< [IN/OUT] Size of buffer when this function is called.
                                    ///           Number of bytes read when this function returns.
)
{
    LE_DEBUG("Reading from modem secure storage [%s]", pathPtr);

    if (ModemSecStorePASoPtr == NULL)
    {
        ModemSecStorePASoPtr = dlopen(ModemSecStorePAPath, RTLD_LAZY);

        if (NULL == ModemSecStorePASoPtr)
        {
            LE_ERROR("Could not open %s.", ModemSecStorePAPath);
            LE_ERROR("%s", dlerror());
            return LE_FAULT;
        }
    }

    static int (*pa_secStore_Read)(const char*, uint8_t*, size_t*) = NULL;
    pa_secStore_Read = dlsym(ModemSecStorePASoPtr, "pa_secStore_Read");
    if (!pa_secStore_Read)
    {
        LE_WARN("Could not get function pa_secStoreModem_Read.");
        LE_ERROR("%s", dlerror());
        return LE_FAULT;
    }

    return pa_secStore_Read(pathPtr, bufPtr, bufSizePtr);
}


//--------------------------------------------------------------------------------------------------
/**
 * Searches configTree for encrypted data stored for a specific path. The encrypted data is
 * decrypted using an existing key and returned to the user.
 *
 *      LE_OK if successful.
 *      LE_OVERFLOW if the buffer is too small to hold all the data.  No data will be written to the
 *                  buffer in this case.
 *      LE_NOT_FOUND if the path is empty.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t Read
(
    const char* keyName,    ///< [IN] Name of the key.
    const char* pathPtr,    ///< [IN] Path to read from.
    uint8_t* bufPtr,        ///< [IN/OUT] Buffer stored in the path.
    size_t* bufSize         ///< [IN/OUT] Size of buffer stored in the path.
)
{
    le_result_t result = LE_OK;
    le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateReadTxn(CFG_SECSTORE);

    if (!le_cfg_NodeExists(iteratorRef, pathPtr))
    {
        result = LE_NOT_FOUND;
    }
    else
    {
        uint8_t encryptedData[MAX_ENCRYPTED_DATA_BYTES];
        uint32_t encryptedDataSize = sizeof(encryptedData);
        uint8_t byte = 0;

        result = le_cfg_GetBinary(iteratorRef,
                                  pathPtr,
                                  encryptedData,
                                  &encryptedDataSize,
                                  &byte,
                                  sizeof(byte));
        if (result != LE_OK)
        {
            LE_ERROR("Failed to get binary [%s].", pathPtr);
            le_cfg_CancelTxn(iteratorRef);
            return result;
        }

        // // Manage case where the data is empty
        if (encryptedDataSize == 0)
        {
            memset(bufPtr, 0, *bufSize);
            *bufSize = 0;
            le_cfg_CancelTxn(iteratorRef);
            return LE_OK;
        }
        else
        {
            uint8_t key[KM_MAX_KEY_SIZE];
            uint32_t keySize = sizeof(key);

            result = GetKey(keyName, key, &keySize);

            if (result != LE_OK)
            {
                LE_ERROR("Unable to get key [%s].", pathPtr);
                le_cfg_CancelTxn(iteratorRef);
                return result;
            }

            result = tz_DecryptData(key, keySize, encryptedData, encryptedDataSize, bufPtr, bufSize);
            if (result != LE_OK)
            {
                LE_ERROR("Unable to decrypt data [%s].", pathPtr);
                le_cfg_CancelTxn(iteratorRef);
                return result;
            }
        }
    }

    le_cfg_CancelTxn(iteratorRef);
    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Deletes the specified path and everything under it in modem secure storage.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t ModemDelete
(
    const char* pathPtr             ///< [IN] Path to delete.
)
{
    LE_DEBUG("Deleting from modem secure storage [%s]", pathPtr);

    // never loaded
    if (ModemSecStorePASoPtr == NULL)
    {
        ModemSecStorePASoPtr = dlopen(ModemSecStorePAPath, RTLD_LAZY);

        // try loading
        if (NULL == ModemSecStorePASoPtr)
        {
            LE_ERROR("Could not open %s.", ModemSecStorePAPath);
            LE_ERROR("%s", dlerror());
            return LE_FAULT;
        }
    }

    static int (*pa_secStore_Delete)(const char*) = NULL;
    pa_secStore_Delete = dlsym(ModemSecStorePASoPtr, "pa_secStore_Delete");
    if (!pa_secStore_Delete)
    {
        LE_WARN("Could not get function pa_secStore_Delete.");
        LE_ERROR("%s", dlerror());
        return LE_FAULT;
    }

    return pa_secStore_Delete(pathPtr);
}


//--------------------------------------------------------------------------------------------------
/**
 * Deletes the path entry from the configTree.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t Delete
(
    const char* pathPtr    ///< [IN] Path to delete.
)
{
    le_result_t result = LE_OK;
    le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateWriteTxn(CFG_SECSTORE);

    if (!le_cfg_NodeExists(iteratorRef, pathPtr))
    {
        le_cfg_CancelTxn(iteratorRef);
        result = LE_NOT_FOUND;
    }
    else
    {
        le_cfg_DeleteNode(iteratorRef, pathPtr);
        le_cfg_CommitTxn(iteratorRef);
    }

    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Gets the size, in bytes, of the data at the specified path and everything under it in modem
 * secure storage.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t ModemGetSize
(
    const char* pathPtr,            ///< [IN] Path.
    size_t* sizePtr                 ///< [OUT] Size in bytes of all items in the path.
)
{
    LE_DEBUG("Get size from modem secure storage [%s]", pathPtr);

    // never loaded
    if (ModemSecStorePASoPtr == NULL)
    {
        ModemSecStorePASoPtr = dlopen(ModemSecStorePAPath, RTLD_LAZY);

        // try loading
        if (NULL == ModemSecStorePASoPtr)
        {
            LE_ERROR("Could not open %s.", ModemSecStorePAPath);
            LE_ERROR("%s", dlerror());
            return LE_FAULT;
        }
    }

    static int (*pa_secStore_GetSize)(const char*, size_t*) = NULL;
    pa_secStore_GetSize = dlsym(ModemSecStorePASoPtr, "pa_secStore_GetSize");
    if (!pa_secStore_GetSize)
    {
        LE_WARN("Could not get function pa_secStore_GetSize.");
        LE_ERROR("%s", dlerror());
        return LE_FAULT;
    }

    return pa_secStore_GetSize(pathPtr, sizePtr);
}


//--------------------------------------------------------------------------------------------------
/**
 * Recursively go through all the paths under the specified iterator, to calculate the total size
 * used to store data, and collect the meta data.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t IteratePathSize
(
    le_cfg_IteratorRef_t iteratorRef, ///< [IN] Iterate through all paths under this iterator.
    size_t isRoot,                    ///< [IN] Used to mark the current iterator as root
                                      ///       so we don't iterate the roots node siblings.
    size_t* totalSizePtr,             ///< [IN/OUT] Total size of all data under the specified
                                      ///           iterator. Ignored if NULL.
    FILE* metaFilePtr                 ///< [IN/OUT] File to write meta data to. Ignored if NULL.
)
{
    le_result_t result = LE_OK;
    static char path[LE_CFG_STR_LEN_BYTES] = "";
    do
    {
        // Get node type
        le_cfg_nodeType_t type = le_cfg_GetNodeType(iteratorRef, "");

        switch (type)
        {
            // A stem node, recruse into the stem's sub-items.
            case LE_CFG_TYPE_STEM:
                le_cfg_GoToFirstChild(iteratorRef);
                result = IteratePathSize(iteratorRef, false, totalSizePtr, metaFilePtr);
                if (result != LE_OK)
                {
                    return result;
                }

                le_cfg_GoToParent(iteratorRef);

                if (isRoot)
                {
                    return result;
                }
                break;
            case LE_CFG_TYPE_EMPTY:
                break;
            default:
                le_cfg_GetPath(iteratorRef, "", path, sizeof(path));

                uint8_t encryptedData[MAX_ENCRYPTED_DATA_BYTES];
                uint32_t encryptedDataSize = sizeof(encryptedData);
                uint8_t byte = 0;

                result = le_cfg_GetBinary(iteratorRef,
                                          "",
                                          encryptedData,
                                          &encryptedDataSize,
                                          &byte,
                                          sizeof(byte));
                if (result != LE_OK)
                {
                    LE_ERROR("Failed to get binary");
                    return LE_NOT_FOUND;
                }

                uint8_t buffer[MAX_ENCRYPTED_DATA_BYTES];
                uint32_t bufferSize = sizeof(buffer);

                // Manage case where the data is empty
                if (encryptedDataSize == 0)
                {
                    bufferSize = 0;
                }
                else
                {
                    // Identify key name for this path
                    char keyName[LIMIT_MAX_APP_NAME_BYTES];
                    SfsPathType_t type = GetPathType(path);
                    if (type == SFS_PATH_TYPE_APP_PATH)
                    {
                        result = GetApplicationName(path, keyName, sizeof(keyName));

                        if (result != LE_OK)
                        {
                            return result;
                        }
                    }
                    else
                    {
                        le_utf8_Copy(keyName, CFG_SECSTORE_USER_PATH, sizeof(keyName), NULL);
                    }

                    // Get key
                    uint8_t key[KM_MAX_KEY_SIZE];
                    uint32_t keySize = sizeof(key);
                    result = GetKey(keyName, key, &keySize);

                    if (result != LE_OK)
                    {
                        LE_ERROR("Unable to get key [%s].", path);
                        return result;
                    }

                    result = tz_DecryptData(key,
                                            keySize,
                                            encryptedData,
                                            encryptedDataSize,
                                            buffer,
                                            &bufferSize);
                    // If the data can't be decrypted (due to lost key file as a result of Legato
                    // downgrade), use the encrypted size in calculations and return OK.
                    // This will allow Write() operation to succeed and overwrite the bad data.
                    if (result != LE_OK)
                    {
                        LE_WARN("Unable to decrypt [%s].", path);
                        bufferSize = encryptedDataSize;
                        result = LE_OK;
                    }
                }

                LE_DEBUG("Path: %s [size: %d]", path, bufferSize);
                if (NULL != metaFilePtr)
                {
                    // meta data written in the way partially compatible with old "meta file":
                    // lines 1,3,5,.. contain path, lines 2,4,6,.. contain item size.
                    fprintf(metaFilePtr, "%s\n%d\n", path, bufferSize);
                }
                if (NULL != totalSizePtr)
                {
                    *totalSizePtr += bufferSize;
                }

                if (isRoot)
                {
                    return result;
                }

                break;
        }
    }
    while (le_cfg_GoToNextSibling(iteratorRef) == LE_OK);

    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Iterate through the configTree to find all data paths that are equivalent or subpaths.
 * Decrypt the data and for all the paths and return the total size.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t GetSize
(
    const char* pathPtr, ///< [IN] Path to get size.
    size_t* sizePtr      ///< [IN/OUT] Size of path.
)
{
    // Determine storage path
    le_result_t result = LE_OK;
    le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateReadTxn(CFG_SECSTORE);
    le_cfg_GoToNode(iteratorRef, pathPtr);

    if (!le_cfg_NodeExists(iteratorRef, ""))
    {
        result = LE_NOT_FOUND;
    }
    else
    {
        result = IteratePathSize(iteratorRef, true, sizePtr, NULL);
    }

    le_cfg_CancelTxn(iteratorRef);
    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Copy modem SFS meta data to a specified path location.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t ModemCopyMetaTo
(
    const char* pathPtr
)
{
    LE_DEBUG("Copy meta data from modem secure storage [%s]", pathPtr);

    // never loaded
    if (ModemSecStorePASoPtr == NULL)
    {
        ModemSecStorePASoPtr = dlopen(ModemSecStorePAPath, RTLD_LAZY);

        // try loading
        if (NULL == ModemSecStorePASoPtr)
        {
            LE_ERROR("Could not open %s.", ModemSecStorePAPath);
            LE_ERROR("%s", dlerror());
            return LE_FAULT;
        }
    }

    static int (*pa_secStore_CopyMetaTo)(const char*) = NULL;
    pa_secStore_CopyMetaTo = dlsym(ModemSecStorePASoPtr, "pa_secStore_CopyMetaTo");
    if (!pa_secStore_CopyMetaTo)
    {
        LE_WARN("Could not get function pa_secStore_Write.");
        LE_ERROR("%s", dlerror());
        return LE_FAULT;
    }

    return pa_secStore_CopyMetaTo(pathPtr);
}



//--------------------------------------------------------------------------------------------------
/**
 * Reads a line of text from the stream up to the first newline or eof.  The output buffer will
 * always be NULL-terminated and will not include the newline.
 *
 * @return
 *      LE_OK if successful.
 *      LE_OVERFLOW if the buffer is too small.  As much of the line as possible will be copied to
 *                  buf.
 *      LE_OUT_OF_RANGE if there is nothing else to read from the file.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t ReadLine
(
    FILE* streamPtr,            ///< [IN] Stream to read from.
    char* bufPtr,               ///< [OUT] Buffer to store the line in.
    size_t bufSize              ///< [IN] Buffer size.
)
{
    char localBuf[bufSize + 1];

    if (fgets(localBuf, sizeof(localBuf), streamPtr) == NULL)
    {
        return LE_OUT_OF_RANGE;
    }

    // Remove the trailing newline char.
    size_t len = strlen(localBuf);

    if (localBuf[len - 1] == '\n')
    {
        localBuf[len - 1] = '\0';
    }

    // Copy the buffer into the user buffer.
    return le_utf8_Copy(bufPtr, localBuf, bufSize, NULL);
}


//--------------------------------------------------------------------------------------------------
/**
 * Reads each path from the meta file that represents all the existing paths in the modem secure
 * storage. For each path in the modem secure storage, we will extract the data from those paths
 * in the modem and re-write them into our new sfs location (configTree).
 *
 * @return
 *      LE_OK if successful.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t CopySfsFromMeta
(
    const char* metaFilePtr
)
{
    // Read the file to get the meta data.
    FILE* filePtr;
    le_result_t result = LE_OK;

    do
    {
        filePtr = le_atomFile_OpenStream(metaFilePtr, LE_FLOCK_READ, NULL);
    }
    while ((filePtr == NULL) && (errno == EINTR));

    // If file doesn't exist
    if (filePtr == NULL)
    {
        LE_ERROR("Meta file %s does not exist.  %m.", metaFilePtr);
        le_atomFile_CancelStream(filePtr);
        return LE_FAULT;
    }

    // Read the path and sfs names from the meta file.
    while (1)
    {
        // Read the path.
        char path[SECSTOREADMIN_MAX_PATH_BYTES];

        result = ReadLine(filePtr, path, sizeof(path));

        if (result == LE_OUT_OF_RANGE)
        {
            break;
        }

        if (result == LE_OVERFLOW)
        {
            LE_CRIT("Item path '%s...' is too long.", path);
            goto handleMetaCorruption;
        }

        // Read the sfs name
        char sfsName[LE_SECSTORE_MAX_NAME_BYTES];
        result = ReadLine(filePtr, sfsName, sizeof(sfsName));

        if (result != LE_OK)
        {
            if (result == LE_OVERFLOW)
            {
                LE_CRIT("sfs name '%s...' is too long.", sfsName);
            }
            else
            {
                LE_CRIT("Unexpected end of meta file.");
            }
            goto handleMetaCorruption;
        }

        // Read this data from modem sfs and write to new location
        uint8_t sfsData[LE_SECSTORE_MAX_ITEM_SIZE];
        size_t sfsDataSize = sizeof(sfsData);
        result = ModemRead(path, sfsData, &sfsDataSize);

        if (result != LE_OK)
        {
            goto handleMetaCorruption;
        }

        char appName[LIMIT_MAX_APP_NAME_BYTES];
        SfsPathType_t type = GetPathType(path);
        if (type == SFS_PATH_TYPE_APP_PATH)
        {
            result = GetApplicationName(path, appName, sizeof(appName));

            if (result != LE_OK)
            {
                goto handleMetaCorruption;
            }
        }
        else
        {
            le_utf8_Copy(appName, CFG_SECSTORE_USER_PATH, sizeof(appName), NULL);
        }

        result = Write(appName, path, sfsData, sfsDataSize, false, NULL);

        if (result != LE_OK)
        {
            goto handleMetaCorruption;
        }

        LE_DEBUG("Migrated [%s] successfully to new SFS.", path);
    }

    le_atomFile_CloseStream(filePtr);

    return LE_OK;

handleMetaCorruption:
    LE_ERROR("Meta data import failed");
    le_atomFile_CancelStream(filePtr);

    return LE_FAULT;
}


//--------------------------------------------------------------------------------------------------
/**
 * Initialize the sfs if is not already initialized.
 *
 * @note
 *      This should be called each time the sfs is accessed to ensure that the sfs is ready for use.
 *
 * @return
 *      LE_OK if successful.
 *      LE_UNAVAILABLE if the sfs is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t InitSfs
(
    void
)
{
    le_result_t result = LE_OK;
    if (!SfsReady)
    {
        LE_DEBUG("Initializing SFS");
        result = ImportKey(KeyMap, KEY_FILE);

        if (result != LE_OK)
        {
            return result;
        }

        // Port old secure storage data from modem SFS.
        // SFS meta data can come from two different sources: modem or FS. This will
        // manage both cases depending on the upgrade path.
        le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateReadTxn(CFG_SECSTORE);
        bool isPorted = le_cfg_GetBool(iteratorRef, "isPorted", false);
        le_cfg_CancelTxn(iteratorRef);

        if (!isPorted)
        {
            struct stat buffer;
            int isSfsV2 = stat(META_FILE, &buffer);

            if (isSfsV2 != 0)
            {
                // Need to pull meta data out of the modem first
                result = ModemCopyMetaTo(TMP_META_FILE);

                if (result != LE_OK)
                {
                    LE_ERROR("Failed to copy meta data to %s", TMP_META_FILE);
                }

                result = CopySfsFromMeta(TMP_META_FILE);
            }
            else
            {
                result = CopySfsFromMeta(META_FILE);
            }

            le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateWriteTxn(CFG_SECSTORE);
            le_cfg_SetBool(iteratorRef, "isPorted", true);
            le_cfg_CommitTxn(iteratorRef);
        }

        SfsReady = true;
    }

    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Writes the data in the buffer to the specified path in secure storage replacing any previously
 * written data at the same path.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NO_MEMORY if there is not enough memory to store the data.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_BAD_PARAMETER if the path cannot be written to because it is a directory or it would
 *                       result in an invalid path.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t pa_secStore_Write
(
    const char* pathPtr,            ///< [IN] Path to write to.
    const uint8_t* bufPtr,          ///< [IN] Buffer containing the data to write.
    size_t bufSize                  ///< [IN] Size of the buffer.
)
{
    LE_DEBUG("Writing: %s", pathPtr);

    // Init the sfs.
    le_result_t result = InitSfs();
    if (result != LE_OK)
    {
        return result;
    }

    char appName[LIMIT_MAX_APP_NAME_BYTES];
    SfsPathType_t type = GetPathType(pathPtr);

    // Access the modem for AVMS use cases
    if (type == SFS_PATH_TYPE_AVMS_PATH)
    {
        return ModemWrite(pathPtr, bufPtr, bufSize);
    }
    else if (type == SFS_PATH_TYPE_APP_PATH)
    {
        result = GetApplicationName(pathPtr, appName, sizeof(appName));

        if (result != LE_OK)
        {
            return result;
        }
    }
    else
    {
        le_utf8_Copy(appName, CFG_SECSTORE_USER_PATH, sizeof(appName), NULL);
    }

    return Write(appName, pathPtr, bufPtr, bufSize, false, NULL);
}


//--------------------------------------------------------------------------------------------------
/**
 * Reads data from the specified path in secure storage.
 *
 * @return
 *      LE_OK if successful.
 *      LE_OVERFLOW if the buffer is too small to hold all the data.  No data will be written to the
 *                  buffer in this case.
 *      LE_NOT_FOUND if the path is empty.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t pa_secStore_Read
(
    const char* pathPtr,            ///< [IN] Path to read from.
    uint8_t* bufPtr,                ///< [OUT] Buffer to store the data in.
    size_t* bufSizePtr              ///< [IN/OUT] Size of buffer when this function is called.
                                    ///          Number of bytes read when this function returns.
)
{
    LE_DEBUG("Reading: %s", pathPtr);

    // Init the sfs.
    le_result_t result = InitSfs();
    if (result != LE_OK)
    {
        return result;
    }

    char appName[LIMIT_MAX_APP_NAME_BYTES];
    SfsPathType_t type = GetPathType(pathPtr);

    // Access the modem for AVMS use cases
    if (type == SFS_PATH_TYPE_AVMS_PATH)
    {
        return ModemRead(pathPtr, bufPtr, bufSizePtr);
    }
    else if (type == SFS_PATH_TYPE_APP_PATH)
    {
        result = GetApplicationName(pathPtr, appName, sizeof(appName));

        if (result != LE_OK)
        {
            return result;
        }
    }
    else
    {
        le_utf8_Copy(appName, CFG_SECSTORE_USER_PATH, sizeof(appName), NULL);
    }

    return Read(appName, pathPtr, bufPtr, bufSizePtr);
}


//--------------------------------------------------------------------------------------------------
/**
 * Write the meta data to the specified path.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the meta data cannot be retrieved.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t pa_secStore_CopyMetaTo
(
    const char* pathPtr             ///< [IN] Destination path of meta file copy.
)
{
    le_result_t result = LE_OK;
    FILE *destFilePtr = le_atomFile_CreateStream(pathPtr, LE_FLOCK_WRITE, LE_FLOCK_REPLACE_IF_EXIST,
                                                 S_IRWXU, NULL);
    if (NULL == destFilePtr)
    {
        return LE_NOT_FOUND;
    }

    le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateReadTxn(CFG_SECSTORE);

    if (!le_cfg_NodeExists(iteratorRef, ""))
    {
        result = LE_NOT_FOUND;
    }
    else
    {
        result = IteratePathSize(iteratorRef, true, NULL, destFilePtr);
    }

    le_cfg_CancelTxn(iteratorRef);
    le_atomFile_CloseStream(destFilePtr);

    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Deletes the specified path and everything under it.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t pa_secStore_Delete
(
    const char* pathPtr             ///< [IN] Path to delete.
)
{
    LE_DEBUG("Deleting: %s", pathPtr);

    // Init the sfs.
    le_result_t result = InitSfs();
    if (result != LE_OK)
    {
        return result;
    }

    SfsPathType_t type = GetPathType(pathPtr);

    // Access the modem for AVMS use cases
    if (type == SFS_PATH_TYPE_AVMS_PATH)
    {
        return ModemDelete(pathPtr);
    }

    return Delete(pathPtr);
}


//--------------------------------------------------------------------------------------------------
/**
 * Gets the size, in bytes, of the data at the specified path and everything under it.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t pa_secStore_GetSize
(
    const char* pathPtr,            ///< [IN] Path.
    size_t* sizePtr                 ///< [OUT] Size in bytes of all items in the path.
)
{
    // Init the sfs.
    le_result_t result = InitSfs();
    if (result != LE_OK)
    {
        return result;
    }

    SfsPathType_t type = GetPathType(pathPtr);

    // Access the modem for AVMS use cases
    if (type == SFS_PATH_TYPE_AVMS_PATH)
    {
        return ModemGetSize(pathPtr, sizePtr);
    }

    return GetSize(pathPtr, sizePtr);
}


//--------------------------------------------------------------------------------------------------
/**
 * Recursively go through all the paths under the specified iterator and call the supplied callback
 * with each entry name.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
static le_result_t IteratePathEntries
(
    le_cfg_IteratorRef_t iteratorRef,       ///< [IN] Path.
    bool isRoot,                            ///< [IN] Used to mark the current iterator as root
                                            ///       so we don't iterate the roots node siblings.
    const char* pathPtr,                    ///< [IN] Path.
    pa_secStore_GetEntry_t getEntryFunc,    ///< [IN] Callback function to call with each entry.
    void* contextPtr                        ///< [IN] Context to be supplied to the callback.
)
{
    le_result_t result = LE_OK;
    static char path[LE_CFG_STR_LEN_BYTES] = "";
    do
    {
        // Get node type
        le_cfg_nodeType_t type = le_cfg_GetNodeType(iteratorRef, "");

        switch (type)
        {
            // A stem node, recruse into the stem's sub-items.
            case LE_CFG_TYPE_STEM:
                le_cfg_GoToFirstChild(iteratorRef);
                result = IteratePathEntries(iteratorRef, false, pathPtr, getEntryFunc, contextPtr);
                if (result != LE_OK)
                {
                    return result;
                }

                le_cfg_GoToParent(iteratorRef);

                if (isRoot)
                {
                    return result;
                }
                break;
            case LE_CFG_TYPE_EMPTY:
                break;
            default:
                le_cfg_GetPath(iteratorRef, "", path, sizeof(path));
                size_t pathLen = strlen(pathPtr);

                // Find the entry string.
                char* entryPtr;

               if (pathPtr[pathLen-1] == '/')
                {
                    entryPtr = (char*)&(path[pathLen]);
                }
                else if (path[pathLen] == '/')
                {
                    entryPtr = (char*)&(path[pathLen + 1]);
                }
                else
                {
                    // There is no entry string, move on.
                    continue;
                }

                // Check if the entry is a directory.
                bool isDir = (strchr(entryPtr, '/') != NULL);

                // Copy the entry to a local buffer.
                char buf[512];

                LE_FATAL_IF(le_utf8_CopyUpToSubStr(buf, entryPtr, "/", sizeof(buf), NULL) != LE_OK,
                            "Buffer too small to hold entry name '%s...'.", buf);

                // Call the callback function.
                if (getEntryFunc != NULL)
                {
                    getEntryFunc(buf, isDir, contextPtr);
                }

                break;
        }
    }
    while (le_cfg_GoToNextSibling(iteratorRef) == LE_OK);

    return result;
}

//--------------------------------------------------------------------------------------------------
/**
 * Iterates over all entries under the specified path, calling the supplied callback
 * with each entry name.
 *
 * @return
 *      LE_OK if successful.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
LE_SHARED le_result_t pa_secStore_GetEntries
(
    const char* pathPtr,                    ///< [IN] Path.
    pa_secStore_GetEntry_t getEntryFunc,    ///< [IN] Callback function to call with each entry.
    void* contextPtr                        ///< [IN] Context to be supplied to the callback.
)
{
    // Init the sfs.
    le_result_t result = InitSfs();
    if (result != LE_OK)
    {
        return result;
    }

    le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateReadTxn(CFG_SECSTORE);
    le_cfg_GoToNode(iteratorRef, pathPtr);

    if (le_cfg_NodeExists(iteratorRef, ""))
    {
        result = IteratePathEntries(iteratorRef, true, pathPtr, getEntryFunc, contextPtr);
    }

    le_cfg_CancelTxn(iteratorRef);

    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Gets the total space and the available free space in secure storage.
 *
 * @return
 *      LE_OK if successful.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t pa_secStore_GetTotalSpace
(
    size_t* totalSpacePtr,                  ///< [OUT] Total size, in bytes, of secure storage.
    size_t* freeSizePtr                     ///< [OUT] Free space, in bytes, in secure storage.
)
{
    size_t usedSize = 0;

    le_result_t result = GetSize("", &usedSize);
    if (LE_NOT_FOUND == result)
    {
        return LE_UNAVAILABLE;
    }
    else if (LE_OK != result)
    {
        return result;
    }

    *totalSpacePtr = SECSTORE_TOTAL_SPACE;
    if (*totalSpacePtr > usedSize)
    {
        *freeSizePtr = *totalSpacePtr - usedSize;
    }
    else
    {
        *freeSizePtr = 0;
    }

    return LE_OK;
}


//--------------------------------------------------------------------------------------------------
/**
 * Recursively go through all the paths under the specified iterator and copy them to a new
 * destination.
 *
 * @return
 *      LE_OK if successful.
 *      LE_NOT_FOUND if the path does not exist.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was an error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t IteratePathCopy
(
    le_cfg_IteratorRef_t iteratorRef,       ///< [IN] Path.
    bool isRoot,                            ///< [IN] Used to mark the current iterator as root
                                            ///       so we don't iterate the roots node siblings.
    const char* destPathPtr,                ///< [IN] Destination path.
    const char* srcPathPtr                  ///< [IN] Source path.
)
{
    le_result_t result = LE_OK;
    static char path[LE_CFG_STR_LEN_BYTES] = "";
    do
    {
        // Get node type
        le_cfg_nodeType_t type = le_cfg_GetNodeType(iteratorRef, "");

        switch (type)
        {
            // A stem node, recruse into the stem's sub-items.
            case LE_CFG_TYPE_STEM:
                le_cfg_GoToFirstChild(iteratorRef);
                result = IteratePathCopy(iteratorRef, false, destPathPtr, srcPathPtr);
                if (result != LE_OK)
                {
                    return result;
                }

                le_cfg_GoToParent(iteratorRef);

                if (isRoot)
                {
                    return result;
                }
                break;
            case LE_CFG_TYPE_EMPTY:
                break;
            default:
                le_cfg_GetPath(iteratorRef, "", path, sizeof(path));

                // Identify key name for this path
                char keyName[LIMIT_MAX_APP_NAME_BYTES];
                SfsPathType_t type = GetPathType(path);
                if (type == SFS_PATH_TYPE_APP_PATH)
                {
                    result = GetApplicationName(path, keyName, sizeof(keyName));

                    if (result != LE_OK)
                    {
                        return result;
                    }
                }
                else
                {
                    le_utf8_Copy(keyName, CFG_SECSTORE_USER_PATH, sizeof(keyName), NULL);
                }

                // Get key
                uint8_t key[KM_MAX_KEY_SIZE];
                uint32_t keySize = sizeof(key);
                result = GetKey(keyName, key, &keySize);

                if (result != LE_OK)
                {
                    LE_ERROR("Unable to get key [%s].", path);
                    return result;
                }

                char destPath[LE_CFG_STR_LEN_BYTES];
                memset(destPath, 0, sizeof(destPath));
                LE_FATAL_IF(le_path_Concat("/",
                                           destPath,
                                           LE_CFG_STR_LEN_BYTES,
                                           destPathPtr,
                                           &(path[strlen(srcPathPtr)]),
                                           NULL) != LE_OK,
                                           "Dest path '%s' is too long.", destPath);

                uint8_t encryptedData[MAX_ENCRYPTED_DATA_BYTES];
                uint32_t encryptedDataSize = sizeof(encryptedData);
                uint8_t byte = 0;

                le_result_t result = le_cfg_GetBinary(iteratorRef,
                                                      "",
                                                      encryptedData,
                                                      &encryptedDataSize,
                                                      &byte,
                                                      sizeof(byte));
                if (result != LE_OK)
                {
                    LE_ERROR("Failed to get binary [%s]", path);
                    le_cfg_CancelTxn(iteratorRef);
                    return LE_NOT_FOUND;
                }

                 // Copy encrypted data to new path
                Write(keyName, destPath, encryptedData, encryptedDataSize, true, iteratorRef);

                LE_DEBUG("Copying %s to %s", path, destPath);

                if (isRoot)
                {
                    return result;
                }

                break;
        }
    }
    while (le_cfg_GoToNextSibling(iteratorRef) == LE_OK);

    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Copies all the data from source path to destination path.  The destination path must be empty.
 *
 * @return
 *      LE_OK if successful.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t pa_secStore_Copy
(
    const char* destPathPtr,                ///< [IN] Destination path.
    const char* srcPathPtr                  ///< [IN] Source path.
)
{
    // Make sure the source and dest paths don't overlap.
    if ( le_path_IsEquivalent(srcPathPtr, destPathPtr, "/") ||
         le_path_IsSubpath(srcPathPtr, destPathPtr, "/") ||
         le_path_IsSubpath(destPathPtr, srcPathPtr, "/") )
    {
        LE_ERROR("Cannot copy %s into itself.", srcPathPtr);
        return LE_FAULT;
    }

    // Init the sfs.
    le_result_t result = InitSfs();
    if (result != LE_OK)
    {
        return result;
    }

    le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateWriteTxn(CFG_SECSTORE);
    le_cfg_GoToNode(iteratorRef, srcPathPtr);

    if (le_cfg_NodeExists(iteratorRef, ""))
    {
        result = IteratePathCopy(iteratorRef, true, destPathPtr, srcPathPtr);
    }

    if (result != LE_OK)
    {
        le_cfg_CancelTxn(iteratorRef);
    }
    else
    {
        le_cfg_CommitTxn(iteratorRef);
    }

    return result;
}


//--------------------------------------------------------------------------------------------------
/**
 * Moves all the data from source path to destination path.  The destination path must be empty.
 * Similar to a copy but we will delete the old data since we cannot rename nodes in cfgTree.
 *
 * @return
 *      LE_OK if successful.
 *      LE_UNAVAILABLE if the secure storage is currently unavailable.
 *      LE_FAULT if there was some other error.
 */
//--------------------------------------------------------------------------------------------------
le_result_t pa_secStore_Move
(
    const char* destPathPtr,                ///< [IN] Destination path.
    const char* srcPathPtr                  ///< [IN] Source path.
)
{
    // Make sure the source and dest paths don't overlap.
    if ( le_path_IsEquivalent(srcPathPtr, destPathPtr, "/") ||
         le_path_IsSubpath(srcPathPtr, destPathPtr, "/") ||
         le_path_IsSubpath(destPathPtr, srcPathPtr, "/") )
    {
        LE_ERROR("Cannot move %s into itself.", srcPathPtr);
        return LE_FAULT;
    }

    // Init the sfs.
    le_result_t result = InitSfs();
    if (result != LE_OK)
    {
        return result;
    }

    le_cfg_IteratorRef_t iteratorRef = le_cfg_CreateWriteTxn(CFG_SECSTORE);
    le_cfg_GoToNode(iteratorRef, srcPathPtr);

    if (le_cfg_NodeExists(iteratorRef, ""))
    {
        result = IteratePathCopy(iteratorRef, true, destPathPtr, srcPathPtr);
    }

    if (result != LE_OK)
    {
        le_cfg_CancelTxn(iteratorRef);
    }
    else
    {
        le_cfg_CommitTxn(iteratorRef);
    }

    // Delete the node
    iteratorRef = le_cfg_CreateWriteTxn(CFG_SECSTORE);
    le_cfg_DeleteNode(iteratorRef, srcPathPtr);
    le_cfg_CommitTxn(iteratorRef);

    return LE_OK;
}


//--------------------------------------------------------------------------------------------------
/**
 * Re-initialize the secure storage if is already initialized.
 *
 * @note
 *      This should be called each time the restore done indication is received in service level,
 *      so that the meta hash can be rebuilt.
 *
 * @return
 */
//--------------------------------------------------------------------------------------------------
LE_SHARED void pa_secStore_ReInitSecStorage
(
    void
)
{
    return;
}

//--------------------------------------------------------------------------------------------------
/**
 * This function must be called to register a handler for restore event in PA level to notify
 * service level.
 */
//--------------------------------------------------------------------------------------------------
LE_SHARED le_event_HandlerRef_t pa_secStore_SetRestoreHandler
(
    pa_secStore_RestoreHdlrFunc_t handlerFuncPtr ///< [IN] The handler function.
)
{
    return NULL;
}


//--------------------------------------------------------------------------------------------------
/**
 * Init this component
 */
//--------------------------------------------------------------------------------------------------
COMPONENT_INIT
{
    LE_INFO("Init TrustZone secure storage platform adaptor.");

    KeyPool = le_mem_CreatePool("KeyNamePool", sizeof(Key_t));

    // Create the key data hash map.
    KeyMap = le_hashmap_Create("SfsFiles",
                                ESTIMATED_MAX_KEYS,
                                le_hashmap_HashString,
                                le_hashmap_EqualsString);
}